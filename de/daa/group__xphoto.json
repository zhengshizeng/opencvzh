[
  {
    "origin": "OpenCV: Additional photo processing algorithms",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "Additional photo processing algorithms",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Gray-world white balance algorithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "More sophisticated learning-based automatic white balance algorithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "A simple white balance algorithm that works by independently stretching each of the input image channels to the specified range. For increased robustness it ignores the top and bottom \\(p\\%\\) of pixel values.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This algorithm decomposes image into two layers: base layer and detail layer using bilateral filter and compresses contrast of the base layer thus preserving all the details.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "The base class for auto white balance algorithms.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "BM3D algorithm steps.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Various inpainting algorithms.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "= 0 }",
    "local": ""
  },
  {
    "origin": "BM3D transform types.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, float gainB, float gainG, float gainR)",
    "local": ""
  },
  {
    "origin": "Implements an efficient fixed-point approximation for applying channel gains, which is the last step of multiple white balance algorithms.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dstStep1,",
    "local": ""
  },
  {
    "origin": "dstStep2, float h=1, int templateWindowSize=4, int searchWindowSize=16, int blockMatchingStep1=2500, int blockMatchingStep2=400, int groupSize=8, int slidingStep=1, float beta=2.0f, int normType=cv::NORM_L2, int step=cv::xphoto::BM3D_STEPALL, int transformType=cv::xphoto::HAAR)",
    "local": ""
  },
  {
    "origin": "Performs image denoising using the Block-Matching and 3D-filtering algorithm",
    "local": ""
  },
  {
    "origin": "http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf",
    "local": ""
  },
  {
    "origin": "with several computational optimizations. Noise expected to be a gaussian white noise.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, float h=1, int templateWindowSize=4, int searchWindowSize=16, int blockMatchingStep1=2500, int blockMatchingStep2=400, int groupSize=8, int slidingStep=1, float beta=2.0f, int normType=cv::NORM_L2, int step=cv::xphoto::BM3D_STEPALL, int transformType=cv::xphoto::HAAR)",
    "local": ""
  },
  {
    "origin": "Performs image denoising using the Block-Matching and 3D-filtering algorithm",
    "local": ""
  },
  {
    "origin": "http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf",
    "local": ""
  },
  {
    "origin": "with several computational optimizations. Noise expected to be a gaussian white noise.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Creates an instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;path_to_model=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Creates an instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Creates an instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(float gamma=1.0f, float contrast=4.0f, float saturation=1.0f, float sigma_color=2.0f, float sigma_space=2.0f)",
    "local": ""
  },
  {
    "origin": "Creates",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src,",
    "local": ""
  },
  {
    "origin": "&amp;dst, const double sigma, const int psize=16)",
    "local": ""
  },
  {
    "origin": "The function implements simple dct-based denoising.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;mask,",
    "local": ""
  },
  {
    "origin": "&amp;dst, const int algorithmType)",
    "local": ""
  },
  {
    "origin": "The function implements different single-image inpainting algorithms.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int size, int dynRatio, int code)",
    "local": ""
  },
  {
    "origin": "oilPainting See the book",
    "local": ""
  },
  {
    "origin": "for details.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int size, int dynRatio)",
    "local": ""
  },
  {
    "origin": "oilPainting See the book",
    "local": ""
  },
  {
    "origin": "for details.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Enumeration Type Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "Bm3dSteps",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "BM3D algorithm steps.",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "BM3D_STEPALL",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.BM3D_STEPALL",
    "local": ""
  },
  {
    "origin": "Execute all steps of the algorithm",
    "local": ""
  },
  {
    "origin": "BM3D_STEP1",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.BM3D_STEP1",
    "local": ""
  },
  {
    "origin": "Execute only first step of the algorithm",
    "local": ""
  },
  {
    "origin": "BM3D_STEP2",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.BM3D_STEP2",
    "local": ""
  },
  {
    "origin": "Execute only second step of the algorithm",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "InpaintTypes",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Various inpainting algorithms.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "INPAINT_SHIFTMAP",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.INPAINT_SHIFTMAP",
    "local": ""
  },
  {
    "origin": "This algorithm searches for dominant correspondences (transformations) of image patches and tries to seamlessly fill-in the area to be inpainted using this transformations",
    "local": ""
  },
  {
    "origin": "INPAINT_FSR_BEST",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.INPAINT_FSR_BEST",
    "local": ""
  },
  {
    "origin": "Performs Frequency Selective Reconstruction (FSR). One of the two quality profiles BEST and FAST can be chosen, depending on the time available for reconstruction. See",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "for details.",
    "local": ""
  },
  {
    "origin": "The algorithm may be utilized for the following areas of application:",
    "local": ""
  },
  {
    "origin": "Error Concealment (Inpainting). The sampling mask indicates the missing pixels of the distorted input image to be reconstructed.",
    "local": ""
  },
  {
    "origin": "Non-Regular Sampling. For more information on how to choose a good sampling mask, please review",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "1-channel grayscale or 3-channel BGR image are accepted.",
    "local": ""
  },
  {
    "origin": "Conventional accepted ranges:",
    "local": ""
  },
  {
    "origin": "0-255 for CV_8U",
    "local": ""
  },
  {
    "origin": "0-65535 for CV_16U",
    "local": ""
  },
  {
    "origin": "0-1 for CV_32F/CV_64F.",
    "local": ""
  },
  {
    "origin": "INPAINT_FSR_FAST",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.INPAINT_FSR_FAST",
    "local": ""
  },
  {
    "origin": "See",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "TransformTypes",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "BM3D transform types.",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "HAAR",
    "local": ""
  },
  {
    "origin": "Python: cv.xphoto.HAAR",
    "local": ""
  },
  {
    "origin": "Un-normalized Haar transform",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "applyChannelGains()",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::applyChannelGains",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "gainB",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "gainG",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "gainR",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.applyChannelGains(",
    "local": ""
  },
  {
    "origin": "src, gainB, gainG, gainR[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Implements an efficient fixed-point approximation for applying channel gains, which is the last step of multiple white balance algorithms.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Input three-channel image in the BGR color space (either CV_8UC3 or CV_16UC3)",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Output image of the same size and type as src.",
    "local": ""
  },
  {
    "origin": "gainB",
    "local": ""
  },
  {
    "origin": "gain for the B channel",
    "local": ""
  },
  {
    "origin": "gainG",
    "local": ""
  },
  {
    "origin": "gain for the G channel",
    "local": ""
  },
  {
    "origin": "gainR",
    "local": ""
  },
  {
    "origin": "gain for the R channel",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "bm3dDenoising()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::bm3dDenoising",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dstStep1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dstStep2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "h",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "templateWindowSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "searchWindowSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "blockMatchingStep1",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "blockMatchingStep2",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "groupSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "slidingStep",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "normType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "step",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "transformType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dstStep1, dstStep2",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.bm3dDenoising(",
    "local": ""
  },
  {
    "origin": "src, dstStep1[, dstStep2[, h[, templateWindowSize[, searchWindowSize[, blockMatchingStep1[, blockMatchingStep2[, groupSize[, slidingStep[, beta[, normType[, step[, transformType]]]]]]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.bm3dDenoising(",
    "local": ""
  },
  {
    "origin": "src[, dst[, h[, templateWindowSize[, searchWindowSize[, blockMatchingStep1[, blockMatchingStep2[, groupSize[, slidingStep[, beta[, normType[, step[, transformType]]]]]]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs image denoising using the Block-Matching and 3D-filtering algorithm",
    "local": ""
  },
  {
    "origin": "http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf",
    "local": ""
  },
  {
    "origin": "with several computational optimizations. Noise expected to be a gaussian white noise.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Input 8-bit or 16-bit 1-channel image.",
    "local": ""
  },
  {
    "origin": "dstStep1",
    "local": ""
  },
  {
    "origin": "Output image of the first step of BM3D with the same size and type as src.",
    "local": ""
  },
  {
    "origin": "dstStep2",
    "local": ""
  },
  {
    "origin": "Output image of the second step of BM3D with the same size and type as src.",
    "local": ""
  },
  {
    "origin": "h",
    "local": ""
  },
  {
    "origin": "Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.",
    "local": ""
  },
  {
    "origin": "templateWindowSize",
    "local": ""
  },
  {
    "origin": "searchWindowSize",
    "local": ""
  },
  {
    "origin": "Size in pixels of the window that is used to perform block-matching. Affect performance linearly: greater searchWindowsSize - greater denoising time. Must be larger than templateWindowSize.",
    "local": ""
  },
  {
    "origin": "blockMatchingStep1",
    "local": ""
  },
  {
    "origin": "Block matching threshold for the first step of BM3D (hard thresholding), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.",
    "local": ""
  },
  {
    "origin": "blockMatchingStep2",
    "local": ""
  },
  {
    "origin": "Block matching threshold for the second step of BM3D (Wiener filtering), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.",
    "local": ""
  },
  {
    "origin": "groupSize",
    "local": ""
  },
  {
    "origin": "Maximum size of the 3D group for collaborative filtering.",
    "local": ""
  },
  {
    "origin": "slidingStep",
    "local": ""
  },
  {
    "origin": "Sliding step to process every next reference block.",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "Kaiser window parameter that affects the sidelobe attenuation of the transform of the window. Kaiser window is used in order to reduce border effects. To prevent usage of the window, set beta to zero.",
    "local": ""
  },
  {
    "origin": "normType",
    "local": ""
  },
  {
    "origin": "Norm used to calculate distance between blocks.",
    "local": ""
  },
  {
    "origin": "is slower than",
    "local": ""
  },
  {
    "origin": "but yields more accurate results.",
    "local": ""
  },
  {
    "origin": "step",
    "local": ""
  },
  {
    "origin": "Step of BM3D to be executed. Possible variants are: step 1, step 2, both steps.",
    "local": ""
  },
  {
    "origin": "transformType",
    "local": ""
  },
  {
    "origin": "Type of the orthogonal transform used in collaborative filtering step. Currently only Haar transform is supported.",
    "local": ""
  },
  {
    "origin": "This function expected to be applied to grayscale images. Advanced usage of this function can be manual denoising of colored image in different colorspaces.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "bm3dDenoising()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::bm3dDenoising",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "h",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "templateWindowSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "searchWindowSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "blockMatchingStep1",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "blockMatchingStep2",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "groupSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "slidingStep",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "normType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "step",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "transformType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dstStep1, dstStep2",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.bm3dDenoising(",
    "local": ""
  },
  {
    "origin": "src, dstStep1[, dstStep2[, h[, templateWindowSize[, searchWindowSize[, blockMatchingStep1[, blockMatchingStep2[, groupSize[, slidingStep[, beta[, normType[, step[, transformType]]]]]]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.bm3dDenoising(",
    "local": ""
  },
  {
    "origin": "src[, dst[, h[, templateWindowSize[, searchWindowSize[, blockMatchingStep1[, blockMatchingStep2[, groupSize[, slidingStep[, beta[, normType[, step[, transformType]]]]]]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs image denoising using the Block-Matching and 3D-filtering algorithm",
    "local": ""
  },
  {
    "origin": "http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf",
    "local": ""
  },
  {
    "origin": "with several computational optimizations. Noise expected to be a gaussian white noise.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Input 8-bit or 16-bit 1-channel image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Output image with the same size and type as src.",
    "local": ""
  },
  {
    "origin": "h",
    "local": ""
  },
  {
    "origin": "Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.",
    "local": ""
  },
  {
    "origin": "templateWindowSize",
    "local": ""
  },
  {
    "origin": "searchWindowSize",
    "local": ""
  },
  {
    "origin": "Size in pixels of the window that is used to perform block-matching. Affect performance linearly: greater searchWindowsSize - greater denoising time. Must be larger than templateWindowSize.",
    "local": ""
  },
  {
    "origin": "blockMatchingStep1",
    "local": ""
  },
  {
    "origin": "Block matching threshold for the first step of BM3D (hard thresholding), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.",
    "local": ""
  },
  {
    "origin": "blockMatchingStep2",
    "local": ""
  },
  {
    "origin": "Block matching threshold for the second step of BM3D (Wiener filtering), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.",
    "local": ""
  },
  {
    "origin": "groupSize",
    "local": ""
  },
  {
    "origin": "Maximum size of the 3D group for collaborative filtering.",
    "local": ""
  },
  {
    "origin": "slidingStep",
    "local": ""
  },
  {
    "origin": "Sliding step to process every next reference block.",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "Kaiser window parameter that affects the sidelobe attenuation of the transform of the window. Kaiser window is used in order to reduce border effects. To prevent usage of the window, set beta to zero.",
    "local": ""
  },
  {
    "origin": "normType",
    "local": ""
  },
  {
    "origin": "Norm used to calculate distance between blocks.",
    "local": ""
  },
  {
    "origin": "is slower than",
    "local": ""
  },
  {
    "origin": "but yields more accurate results.",
    "local": ""
  },
  {
    "origin": "step",
    "local": ""
  },
  {
    "origin": "Step of BM3D to be executed. Allowed are only BM3D_STEP1 and BM3D_STEPALL. BM3D_STEP2 is not allowed as it requires basic estimate to be present.",
    "local": ""
  },
  {
    "origin": "transformType",
    "local": ""
  },
  {
    "origin": "Type of the orthogonal transform used in collaborative filtering step. Currently only Haar transform is supported.",
    "local": ""
  },
  {
    "origin": "This function expected to be applied to grayscale images. Advanced usage of this function can be manual denoising of colored image in different colorspaces.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "createGrayworldWB()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::xphoto::createGrayworldWB",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.createGrayworldWB(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates an instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "createLearningBasedWB()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::xphoto::createLearningBasedWB",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "path_to_model",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.createLearningBasedWB(",
    "local": ""
  },
  {
    "origin": "[, path_to_model]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates an instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "path_to_model",
    "local": ""
  },
  {
    "origin": "Path to a .yml file with the model. If not specified, the default model is used",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "createSimpleWB()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::xphoto::createSimpleWB",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.createSimpleWB(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates an instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "createTonemapDurand()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::xphoto::createTonemapDurand",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "gamma",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "contrast",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "saturation",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "sigma_color",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "sigma_space",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.createTonemapDurand(",
    "local": ""
  },
  {
    "origin": "[, gamma[, contrast[, saturation[, sigma_color[, sigma_space]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "You need to set the OPENCV_ENABLE_NONFREE option in cmake to use those. Use them at your own risk.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "gamma",
    "local": ""
  },
  {
    "origin": "gamma value for gamma correction. See createTonemap",
    "local": ""
  },
  {
    "origin": "contrast",
    "local": ""
  },
  {
    "origin": "resulting contrast on logarithmic scale, i. e. log(max / min), where max and min are maximum and minimum luminance values of the resulting image.",
    "local": ""
  },
  {
    "origin": "saturation",
    "local": ""
  },
  {
    "origin": "saturation enhancement value. See createTonemapDrago",
    "local": ""
  },
  {
    "origin": "sigma_color",
    "local": ""
  },
  {
    "origin": "bilateral filter sigma in color space",
    "local": ""
  },
  {
    "origin": "sigma_space",
    "local": ""
  },
  {
    "origin": "bilateral filter sigma in coordinate space",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "dctDenoising()",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::dctDenoising",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const double",
    "local": ""
  },
  {
    "origin": "sigma",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const int",
    "local": ""
  },
  {
    "origin": "psize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.dctDenoising(",
    "local": ""
  },
  {
    "origin": "src, dst, sigma[, psize]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "The function implements simple dct-based denoising.",
    "local": ""
  },
  {
    "origin": "http://www.ipol.im/pub/art/2011/ys-dct/",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "source image",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "destination image",
    "local": ""
  },
  {
    "origin": "sigma",
    "local": ""
  },
  {
    "origin": "expected noise standard deviation",
    "local": ""
  },
  {
    "origin": "psize",
    "local": ""
  },
  {
    "origin": "size of block side where dct is computed",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getContrast()",
    "local": ""
  },
  {
    "origin": "virtual float cv::xphoto::TonemapDurand::getContrast",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.getContrast(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getSaturation()",
    "local": ""
  },
  {
    "origin": "virtual float cv::xphoto::TonemapDurand::getSaturation",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.getSaturation(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getSigmaColor()",
    "local": ""
  },
  {
    "origin": "virtual float cv::xphoto::TonemapDurand::getSigmaColor",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.getSigmaColor(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getSigmaSpace()",
    "local": ""
  },
  {
    "origin": "virtual float cv::xphoto::TonemapDurand::getSigmaSpace",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.getSigmaSpace(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "inpaint()",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::inpaint",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "mask",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const int",
    "local": ""
  },
  {
    "origin": "algorithmType",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.inpaint(",
    "local": ""
  },
  {
    "origin": "src, mask, dst, algorithmType",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "The function implements different single-image inpainting algorithms.",
    "local": ""
  },
  {
    "origin": "See the original papers",
    "local": ""
  },
  {
    "origin": "(Shiftmap) or",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "(FSR) for details.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "source image",
    "local": ""
  },
  {
    "origin": ": it could be of any type and any number of channels from 1 to 4. In case of 3- and 4-channels images the function expect them in CIELab colorspace or similar one, where first color component shows intensity, while second and third shows colors. Nonetheless you can try any colorspaces.",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": ": 1-channel grayscale or 3-channel BGR image.",
    "local": ""
  },
  {
    "origin": "mask",
    "local": ""
  },
  {
    "origin": "mask (",
    "local": ""
  },
  {
    "origin": "), where non-zero pixels indicate valid image area, while zero pixels indicate area to be inpainted",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "destination image",
    "local": ""
  },
  {
    "origin": "algorithmType",
    "local": ""
  },
  {
    "origin": "see",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "oilPainting()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::oilPainting",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dynRatio",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "code",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.oilPainting(",
    "local": ""
  },
  {
    "origin": "src, size, dynRatio, code[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.oilPainting(",
    "local": ""
  },
  {
    "origin": "src, size, dynRatio[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "oilPainting See the book",
    "local": ""
  },
  {
    "origin": "for details.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Input three-channel or one channel image (either CV_8UC3 or CV_8UC1)",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Output image of the same size and type as src.",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "neighbouring size is 2-size+1",
    "local": ""
  },
  {
    "origin": "dynRatio",
    "local": ""
  },
  {
    "origin": "image is divided by dynRatio before histogram processing",
    "local": ""
  },
  {
    "origin": "code",
    "local": ""
  },
  {
    "origin": "color space conversion code(see ColorConversionCodes). Histogram will used only first plane",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "oilPainting()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "void cv::xphoto::oilPainting",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dynRatio",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.oilPainting(",
    "local": ""
  },
  {
    "origin": "src, size, dynRatio, code[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto.oilPainting(",
    "local": ""
  },
  {
    "origin": "src, size, dynRatio[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "oilPainting See the book",
    "local": ""
  },
  {
    "origin": "for details.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Input three-channel or one channel image (either CV_8UC3 or CV_8UC1)",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Output image of the same size and type as src.",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "neighbouring size is 2-size+1",
    "local": ""
  },
  {
    "origin": "dynRatio",
    "local": ""
  },
  {
    "origin": "image is divided by dynRatio before histogram processing",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setContrast()",
    "local": ""
  },
  {
    "origin": "virtual void cv::xphoto::TonemapDurand::setContrast",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "contrast",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.setContrast(",
    "local": ""
  },
  {
    "origin": "contrast",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setSaturation()",
    "local": ""
  },
  {
    "origin": "virtual void cv::xphoto::TonemapDurand::setSaturation",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "saturation",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.setSaturation(",
    "local": ""
  },
  {
    "origin": "saturation",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setSigmaColor()",
    "local": ""
  },
  {
    "origin": "virtual void cv::xphoto::TonemapDurand::setSigmaColor",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "sigma_color",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.setSigmaColor(",
    "local": ""
  },
  {
    "origin": "sigma_color",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setSigmaSpace()",
    "local": ""
  },
  {
    "origin": "virtual void cv::xphoto::TonemapDurand::setSigmaSpace",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "sigma_space",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.xphoto_TonemapDurand.setSigmaSpace(",
    "local": ""
  },
  {
    "origin": "sigma_space",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:42 for OpenCV by",
    "local": ""
  }
]