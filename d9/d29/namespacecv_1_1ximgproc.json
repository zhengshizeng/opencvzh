[
  {
    "origin": "OpenCV: cv::ximgproc Namespace Reference",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Typedefs",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "cv::ximgproc Namespace Reference",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Interface for Adaptive Manifold Filter realizations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "struct",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class for",
    "local": ""
  },
  {
    "origin": "algorithms.",
    "local": ""
  },
  {
    "origin": "match two contours \\( z_a \\) and \\( z_b \\) minimizing distance",
    "local": ""
  },
  {
    "origin": "\\[ d(z_a,z_b)=\\sum (a_n - s b_n e^{j(n \\alpha +\\phi )})^2 \\]",
    "local": ""
  },
  {
    "origin": "where \\( a_n \\) and \\( b_n \\) are Fourier descriptors of \\( z_a \\) and \\( z_b \\) and s is a scaling factor and \\( \\phi \\) is angle rotation and \\( \\alpha \\) is starting point factor adjustement.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Main interface for all disparity map filters.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Disparity map filter based on Weighted Least Squares filter (in form of Fast Global Smoother that is a lot faster than traditional Weighted Least Squares filter implementations) and optional use of left-right-consistency-based confidence to refine the results in half-occlusions and uniform areas.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Interface for realizations of Domain Transform filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Sparse match interpolation algorithm based on modified locally-weighted affine estimator from",
    "local": ""
  },
  {
    "origin": "and Fast Global Smoother as post-processing filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing",
    "local": ""
  },
  {
    "origin": "algorithm from",
    "local": ""
  },
  {
    "origin": ":",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing the ED (",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": ", EDLines",
    "local": ""
  },
  {
    "origin": ", EDPF",
    "local": ""
  },
  {
    "origin": "and EDCircles",
    "local": ""
  },
  {
    "origin": "algorithms.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Interface for implementations of Fast Bilateral Solver.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Interface for implementations of Fast Global Smoother filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing the FLD (Fast Line Detector) algorithm described in",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Interface for realizations of Guided Filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Sparse match interpolation algorithm based on modified piecewise locally-weighted affine estimator called Robust Interpolation method of Correspondences or RIC from",
    "local": ""
  },
  {
    "origin": "and Variational and Fast Global Smoother as post-processing filter. The",
    "local": ""
  },
  {
    "origin": "is a extension of the",
    "local": ""
  },
  {
    "origin": ". Main concept of this extension is an piece-wise affine model based on over-segmentation via SLIC superpixel estimation. The method contains an efficient propagation mechanism to estimate among the pieces-wise models.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Applies Ridge Detection Filter to an input image. Implements Ridge detection similar to the one in",
    "local": ""
  },
  {
    "origin": "Mathematica",
    "local": ""
  },
  {
    "origin": "using the eigen values from the Hessian Matrix of the input image using Sobel Derivatives. Additional refinement can be done using Skeletonization and Binarization. Adapted from",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Main interface for all filters, that take sparse matches as an input and produce a dense per-pixel matching (optical flow) as an output.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing edge detection algorithm from",
    "local": ""
  },
  {
    "origin": ":",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing the LSC (Linear Spectral Clustering) superpixels algorithm described in",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing the SEEDS (Superpixels Extracted via Energy-Driven Sampling) superpixels algorithm described in",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Class implementing the SLIC (Simple Linear Iterative Clustering) superpixels algorithm described in",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Typedefs",
    "local": ""
  },
  {
    "origin": "typedef std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specifies the part of Hough space to calculate.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specifies to do or not to do skewing of Hough transform image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specifies binary operations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specifies the binarization method to use in",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "= 0x00,",
    "local": ""
  },
  {
    "origin": "= 0x01",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specifies the degree of rules validation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "= 1 &lt;&lt; 1,",
    "local": ""
  },
  {
    "origin": "= 1 &lt;&lt; 2,",
    "local": ""
  },
  {
    "origin": "= 1 &lt;&lt; 3,",
    "local": ""
  },
  {
    "origin": "= 1 &lt;&lt; 4,",
    "local": ""
  },
  {
    "origin": "= 1 &lt;&lt; 5",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specifies weight types of weighted median filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "joint,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, double sigma_s, double sigma_r, bool adjust_outliers=false)",
    "local": ""
  },
  {
    "origin": "Simple one-line Adaptive Manifold Filter call.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, float alpha, float K, int niters)",
    "local": ""
  },
  {
    "origin": "Performs anisotropic diffusion on an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int fr=3, int numIter=1, double sigmaAlpha=-1., double sigmaAvg=-1.)",
    "local": ""
  },
  {
    "origin": "Applies the bilateral texture filter to an image. It performs structure-preserving texture filter. For more details about this filter see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;_original,",
    "local": ""
  },
  {
    "origin": "&amp;_edgeview, int contrast=1, int shortrange=3, int longrange=9)",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img,",
    "local": ""
  },
  {
    "origin": "templ,",
    "local": ""
  },
  {
    "origin": "result)",
    "local": ""
  },
  {
    "origin": "Compares a color template against overlapped color image regions.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "GT,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "ROI, int thresh=24)",
    "local": ""
  },
  {
    "origin": "Function for computing the percent of \"bad\" pixels in the disparity map (pixels where error is higher than a specified threshold)",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "GT,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "ROI)",
    "local": ""
  },
  {
    "origin": "Function for computing mean square error for disparity maps.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "out, int nbElt)",
    "local": ""
  },
  {
    "origin": "Contour sampling .",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int windowRows, int windowCols)",
    "local": ""
  },
  {
    "origin": "Computes the estimated covariance matrix of an image using the sliding window forumlation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(double sigma_s, double sigma_r, bool adjust_outliers=false)",
    "local": ""
  },
  {
    "origin": "Factory method, create instance of",
    "local": ""
  },
  {
    "origin": "and produce some initialization routines.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(int ctr=1024, int fd=16)",
    "local": ""
  },
  {
    "origin": "create",
    "local": ""
  },
  {
    "origin": "algorithm object",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; matcher_left)",
    "local": ""
  },
  {
    "origin": "Convenience factory method that creates an instance of",
    "local": ""
  },
  {
    "origin": "and sets up all the relevant filter parameters automatically based on the matcher instance. Currently supports only",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(bool use_confidence)",
    "local": ""
  },
  {
    "origin": "More generic factory method, create instance of",
    "local": ""
  },
  {
    "origin": "and execute basic initialization routines. When using this method you will need to set-up the ROI, matchers and other parameters by yourself.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide, double sigmaSpatial, double sigmaColor, int mode=",
    "local": ""
  },
  {
    "origin": ", int numIters=3)",
    "local": ""
  },
  {
    "origin": "Factory method, create instance of",
    "local": ""
  },
  {
    "origin": "and produce initialization routines.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Factory method that creates an instance of the",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(float alpha=0.65f, float beta=0.75f, float eta=1, float minScore=0.01f, int maxBoxes=10000, float edgeMinMag=0.1f, float edgeMergeThr=0.5f, float clusterMinMag=0.5f, float maxAspectRatio=3, float minBoxArea=1000, float gamma=2, float kappa=1.5f)",
    "local": ""
  },
  {
    "origin": "Creates a Edgeboxes.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Creates a smart pointer to a",
    "local": ""
  },
  {
    "origin": "object and initializes it.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda=128.0, int num_iter=25, double max_tol=1e-5)",
    "local": ""
  },
  {
    "origin": "Factory method, create instance of",
    "local": ""
  },
  {
    "origin": "and execute the initialization routines.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide, double lambda, double sigma_color, double lambda_attenuation=0.25, int num_iter=3)",
    "local": ""
  },
  {
    "origin": "Factory method, create instance of",
    "local": ""
  },
  {
    "origin": "and execute the initialization routines.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(int _length_threshold=10, float _distance_threshold=1.414213562f, double _canny_th1=50.0, double _canny_th2=50.0, int _canny_aperture_size=3, bool _do_merge=false)",
    "local": ""
  },
  {
    "origin": "Creates a smart pointer to a",
    "local": ""
  },
  {
    "origin": "object and initializes it.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide, int radius, double eps)",
    "local": ""
  },
  {
    "origin": "Factory method, create instance of",
    "local": ""
  },
  {
    "origin": "and produce initialization routines.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img,",
    "local": ""
  },
  {
    "origin": "qimg)",
    "local": ""
  },
  {
    "origin": "creates a quaternion image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Factory method that creates an instance of the",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; matcher_left)",
    "local": ""
  },
  {
    "origin": "Convenience method to set up the matcher for computing the right-view disparity map that is required in case of filtering with confidence.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;model,",
    "local": ""
  },
  {
    "origin": "&lt; const",
    "local": ""
  },
  {
    "origin": "&gt; howToGetFeatures=",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;())",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image, int region_size=10, float ratio=0.075f)",
    "local": ""
  },
  {
    "origin": "Class implementing the LSC (Linear Spectral Clustering) superpixels.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior=2, int histogram_bins=5, bool double_step=false)",
    "local": ""
  },
  {
    "origin": "Initializes a",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image, int algorithm=",
    "local": ""
  },
  {
    "origin": ", int region_size=10, float ruler=10.0f)",
    "local": ""
  },
  {
    "origin": "Initialize a",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, double sigmaSpatial, double sigmaColor, int mode=",
    "local": ""
  },
  {
    "origin": ", int numIters=3)",
    "local": ""
  },
  {
    "origin": "Simple one-line Domain Transform filter call. If you have multiple images to filter with the same guided image then use",
    "local": ""
  },
  {
    "origin": "interface to avoid extra computations on initialization stage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int d, double",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Smoothes an image using the Edge-Preserving filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "confidence,",
    "local": ""
  },
  {
    "origin": "dst, double sigma_spatial=8, double sigma_luma=8, double sigma_chroma=8, double lambda=128.0, int num_iter=25, double max_tol=1e-5)",
    "local": ""
  },
  {
    "origin": "Simple one-line Fast Bilateral Solver filter call. If you have multiple images to filter with the same guide then use",
    "local": ""
  },
  {
    "origin": "interface to avoid extra computations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, double lambda, double sigma_color, double lambda_attenuation=0.25, int num_iter=3)",
    "local": ""
  },
  {
    "origin": "Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same guide then use",
    "local": ""
  },
  {
    "origin": "interface to avoid extra computations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int dstMatDepth, int angleRange=",
    "local": ""
  },
  {
    "origin": ", int op=",
    "local": ""
  },
  {
    "origin": ", int makeSkew=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates 2D Fast Hough transform of an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int nbElt=-1, int nbFD=-1)",
    "local": ""
  },
  {
    "origin": "Fourier descriptors for planed closed curves.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, double scale=1.0)",
    "local": ""
  },
  {
    "origin": "Function for creating a disparity map visualization (clamped CV_8U image)",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "op,",
    "local": ""
  },
  {
    "origin": "dst, double alpha, double omega)",
    "local": ""
  },
  {
    "origin": "Applies X Deriche filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "op,",
    "local": ""
  },
  {
    "origin": "dst, double alpha, double omega)",
    "local": ""
  },
  {
    "origin": "Applies Y Deriche filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "op,",
    "local": ""
  },
  {
    "origin": "_dst, double alpha, double omega)",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "op,",
    "local": ""
  },
  {
    "origin": "_dst, double alpha, double omega)",
    "local": ""
  },
  {
    "origin": "Applies Paillou filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "guide,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int radius, double eps, int dDepth=-1)",
    "local": ""
  },
  {
    "origin": "Simple one-line Guided Filter call.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;houghPoint,",
    "local": ""
  },
  {
    "origin": "srcImgInfo, int angleRange=",
    "local": ""
  },
  {
    "origin": ", int makeSkew=",
    "local": ""
  },
  {
    "origin": ", int rules=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates coordinates of line segment corresponded by point in Hough space.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "joint,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int d, double sigmaColor, double sigmaSpace, int borderType=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies the joint bilateral filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, double lambda=0.02, double kappa=2.0)",
    "local": ""
  },
  {
    "origin": "Global image smoothing via L0 gradient minimization.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "_src,",
    "local": ""
  },
  {
    "origin": "_dst, double maxValue, int type, int blockSize, double k, int binarizationMethod=",
    "local": ""
  },
  {
    "origin": ", double r=128)",
    "local": ""
  },
  {
    "origin": "Performs thresholding on input images using Niblack's technique or some of the popular variations it inspired.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "I)",
    "local": ""
  },
  {
    "origin": "Calculates an affine transformation that normalize given image using Pei&amp;Lin Normalization.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "I,",
    "local": ""
  },
  {
    "origin": "T)",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "qimg,",
    "local": ""
  },
  {
    "origin": "qcimg)",
    "local": ""
  },
  {
    "origin": "calculates conjugate of a quaternion image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img,",
    "local": ""
  },
  {
    "origin": "qimg, int flags, bool sideLeft)",
    "local": ""
  },
  {
    "origin": "Performs a forward or inverse Discrete quaternion Fourier transform of a 2D quaternion array.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1,",
    "local": ""
  },
  {
    "origin": "src2,",
    "local": ""
  },
  {
    "origin": "dst)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element quaternion product of two arrays.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "qimg,",
    "local": ""
  },
  {
    "origin": "qnimg)",
    "local": ""
  },
  {
    "origin": "divides each element by its modulus.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src_path,",
    "local": ""
  },
  {
    "origin": "dst)",
    "local": ""
  },
  {
    "origin": "Function for reading ground truth disparity maps. Supports basic Middlebury and MPI-Sintel formats. Note that the resulting disparity map is scaled by 16.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int d=-1, double sigmaColor=25, double sigmaSpace=3, int numOfIter=4, int borderType=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies the rolling guidance filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int thinningType=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies a binary blob thinning operation, to achieve a skeletization of the input image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "t,",
    "local": ""
  },
  {
    "origin": "dst, bool fdContour=true)",
    "local": ""
  },
  {
    "origin": "transform a contour",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "joint,",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int r, double sigma=25.5, int weightType=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "mask=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies weighted median filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Enumeration Type Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "AngleRangeOption",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specifies the part of Hough space to calculate.",
    "local": ""
  },
  {
    "origin": "The enum specifies the part of Hough space to calculate. Each member specifies primarily direction of lines (horizontal or vertical) and the direction of angle changes. Direction of angle changes is from multiples of 90 to odd multiples of 45. The image considered to be written top-down and left-to-right. Angles are started from vertical line and go clockwise. Separate quarters and halves are written in orientation they should be in full Hough space.",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "ARO_0_45",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_0_45",
    "local": ""
  },
  {
    "origin": "ARO_45_90",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_45_90",
    "local": ""
  },
  {
    "origin": "ARO_90_135",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_90_135",
    "local": ""
  },
  {
    "origin": "ARO_315_0",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_315_0",
    "local": ""
  },
  {
    "origin": "ARO_315_45",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_315_45",
    "local": ""
  },
  {
    "origin": "ARO_45_135",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_45_135",
    "local": ""
  },
  {
    "origin": "ARO_315_135",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_315_135",
    "local": ""
  },
  {
    "origin": "ARO_CTR_HOR",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_CTR_HOR",
    "local": ""
  },
  {
    "origin": "ARO_CTR_VER",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.ARO_CTR_VER",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "HoughDeskewOption",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specifies to do or not to do skewing of Hough transform image.",
    "local": ""
  },
  {
    "origin": "The enum specifies to do or not to do skewing of Hough transform image so it would be no cycling in Hough transform image through borders of image.",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "HDO_RAW",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.HDO_RAW",
    "local": ""
  },
  {
    "origin": "HDO_DESKEW",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.HDO_DESKEW",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "HoughOp",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specifies binary operations.",
    "local": ""
  },
  {
    "origin": "The enum specifies binary operations, that is such ones which involve two operands. Formally, a binary operation \\( f \\) on a set \\( S \\) is a binary relation that maps elements of the Cartesian product \\( S \\times S \\) to \\( S \\):",
    "local": ""
  },
  {
    "origin": "\\[ f: S \\times S \\to S \\]",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "FHT_MIN",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.FHT_MIN",
    "local": ""
  },
  {
    "origin": "FHT_MAX",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.FHT_MAX",
    "local": ""
  },
  {
    "origin": "FHT_ADD",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.FHT_ADD",
    "local": ""
  },
  {
    "origin": "FHT_AVE",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.FHT_AVE",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "LocalBinarizationMethods",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specifies the binarization method to use in",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "BINARIZATION_NIBLACK",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.BINARIZATION_NIBLACK",
    "local": ""
  },
  {
    "origin": "Classic Niblack binarization. See",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "BINARIZATION_SAUVOLA",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.BINARIZATION_SAUVOLA",
    "local": ""
  },
  {
    "origin": "Sauvola's technique. See",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "BINARIZATION_WOLF",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.BINARIZATION_WOLF",
    "local": ""
  },
  {
    "origin": "Wolf's technique. See",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "BINARIZATION_NICK",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.BINARIZATION_NICK",
    "local": ""
  },
  {
    "origin": "NICK technique. See",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "RulesOption",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specifies the degree of rules validation.",
    "local": ""
  },
  {
    "origin": "The enum specifies the degree of rules validation. This can be used, for example, to choose a proper way of input arguments validation.",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "RO_STRICT",
    "local": ""
  },
  {
    "origin": "Validate each rule in a proper way.",
    "local": ""
  },
  {
    "origin": "RO_IGNORE_BORDERS",
    "local": ""
  },
  {
    "origin": "Skip validations of image borders.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "ThinningTypes",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "THINNING_ZHANGSUEN",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.THINNING_ZHANGSUEN",
    "local": ""
  },
  {
    "origin": "THINNING_GUOHALL",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.THINNING_GUOHALL",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "WMFWeightType",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specifies weight types of weighted median filter.",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "WMF_EXP",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.WMF_EXP",
    "local": ""
  },
  {
    "origin": "\\(exp(-|I1-I2|^2/(2*sigma^2))\\)",
    "local": ""
  },
  {
    "origin": "WMF_IV1",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.WMF_IV1",
    "local": ""
  },
  {
    "origin": "\\((|I1-I2|+sigma)^-1\\)",
    "local": ""
  },
  {
    "origin": "WMF_IV2",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.WMF_IV2",
    "local": ""
  },
  {
    "origin": "\\((|I1-I2|^2+sigma^2)^-1\\)",
    "local": ""
  },
  {
    "origin": "WMF_COS",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.WMF_COS",
    "local": ""
  },
  {
    "origin": "\\(dot(I1,I2)/(|I1|*|I2|)\\)",
    "local": ""
  },
  {
    "origin": "WMF_JAC",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.WMF_JAC",
    "local": ""
  },
  {
    "origin": "\\((min(r1,r2)+min(g1,g2)+min(b1,b2))/(max(r1,r2)+max(g1,g2)+max(b1,b2))\\)",
    "local": ""
  },
  {
    "origin": "WMF_OFF",
    "local": ""
  },
  {
    "origin": "Python: cv.ximgproc.WMF_OFF",
    "local": ""
  },
  {
    "origin": "unweighted",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "BrightEdges()",
    "local": ""
  },
  {
    "origin": "void cv::ximgproc::BrightEdges",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "_original",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "_edgeview",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "contrast",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "shortrange",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "longrange",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "covarianceEstimation()",
    "local": ""
  },
  {
    "origin": "void cv::ximgproc::covarianceEstimation",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "windowRows",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "windowCols",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ximgproc.covarianceEstimation(",
    "local": ""
  },
  {
    "origin": "src, windowRows, windowCols[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Computes the estimated covariance matrix of an image using the sliding window forumlation.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "The source image. Input image must be of a complex type.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "The destination estimated covariance matrix. Output matrix will be size (windowRows*windowCols, windowRows*windowCols).",
    "local": ""
  },
  {
    "origin": "windowRows",
    "local": ""
  },
  {
    "origin": "The number of rows in the window.",
    "local": ""
  },
  {
    "origin": "windowCols",
    "local": ""
  },
  {
    "origin": "The number of cols in the window. The window size parameters control the accuracy of the estimation. The sliding window moves over the entire image from the top-left corner to the bottom right corner. Each location of the window represents a sample. If the window is the size of the image, then this gives the exact covariance matrix. For all other cases, the sizes of the window will impact the number of samples and the number of elements in the estimated covariance matrix.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "FastHoughTransform()",
    "local": ""
  },
  {
    "origin": "void cv::ximgproc::FastHoughTransform",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dstMatDepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "angleRange",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "op",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "makeSkew",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ximgproc.FastHoughTransform(",
    "local": ""
  },
  {
    "origin": "src, dstMatDepth[, dst[, angleRange[, op[, makeSkew]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates 2D Fast Hough transform of an image.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "The destination image, result of transformation.",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "The source (input) image.",
    "local": ""
  },
  {
    "origin": "dstMatDepth",
    "local": ""
  },
  {
    "origin": "The depth of destination image",
    "local": ""
  },
  {
    "origin": "op",
    "local": ""
  },
  {
    "origin": "The operation to be applied, see cv::HoughOp",
    "local": ""
  },
  {
    "origin": "angleRange",
    "local": ""
  },
  {
    "origin": "The part of Hough space to calculate, see cv::AngleRangeOption",
    "local": ""
  },
  {
    "origin": "makeSkew",
    "local": ""
  },
  {
    "origin": "Specifies to do or not to do image skewing, see cv::HoughDeskewOption",
    "local": ""
  },
  {
    "origin": "The function calculates the fast Hough transform for full, half or quarter range of angles.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "HoughPoint2Line()",
    "local": ""
  },
  {
    "origin": "cv::ximgproc::HoughPoint2Line",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "houghPoint",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "srcImgInfo",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "angleRange",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "makeSkew",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "rules",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ximgproc.HoughPoint2Line(",
    "local": ""
  },
  {
    "origin": "houghPoint, srcImgInfo[, angleRange[, makeSkew[, rules]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates coordinates of line segment corresponded by point in Hough space.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "houghPoint",
    "local": ""
  },
  {
    "origin": "Point in Hough space.",
    "local": ""
  },
  {
    "origin": "srcImgInfo",
    "local": ""
  },
  {
    "origin": "The source (input) image of Hough transform.",
    "local": ""
  },
  {
    "origin": "angleRange",
    "local": ""
  },
  {
    "origin": "The part of Hough space where point is situated, see cv::AngleRangeOption",
    "local": ""
  },
  {
    "origin": "makeSkew",
    "local": ""
  },
  {
    "origin": "Specifies to do or not to do image skewing, see cv::HoughDeskewOption",
    "local": ""
  },
  {
    "origin": "rules",
    "local": ""
  },
  {
    "origin": "Specifies strictness of line segment calculating, see cv::RulesOption",
    "local": ""
  },
  {
    "origin": "Return values",
    "local": ""
  },
  {
    "origin": "[Vec4i]",
    "local": ""
  },
  {
    "origin": "Coordinates of line segment corresponded by point in Hough space.",
    "local": ""
  },
  {
    "origin": "Remarks",
    "local": ""
  },
  {
    "origin": "If rules parameter set to RO_STRICT then returned line cut along the border of source image.",
    "local": ""
  },
  {
    "origin": "If rules parameter set to RO_WEAK then in case of point, which belongs the incorrect part of Hough image, returned line will not intersect source image.",
    "local": ""
  },
  {
    "origin": "The function calculates coordinates of line segment corresponded by point in Hough space.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "weightedMedianFilter()",
    "local": ""
  },
  {
    "origin": "void cv::ximgproc::weightedMedianFilter",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "joint",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "r",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "sigma",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "weightType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "mask",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ximgproc.weightedMedianFilter(",
    "local": ""
  },
  {
    "origin": "joint, src, r[, dst[, sigma[, weightType[, mask]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies weighted median filter to an image.",
    "local": ""
  },
  {
    "origin": "For more details about this implementation, please see",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "joint",
    "local": ""
  },
  {
    "origin": "Joint 8-bit, 1-channel or 3-channel image.",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source 8-bit or floating-point, 1-channel or 3-channel image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination image.",
    "local": ""
  },
  {
    "origin": "r",
    "local": ""
  },
  {
    "origin": "Radius of filtering kernel, should be a positive integer.",
    "local": ""
  },
  {
    "origin": "sigma",
    "local": ""
  },
  {
    "origin": "Filter range standard deviation for the joint image.",
    "local": ""
  },
  {
    "origin": "weightType",
    "local": ""
  },
  {
    "origin": "weightType The type of weight definition, see WMFWeightType",
    "local": ""
  },
  {
    "origin": "mask",
    "local": ""
  },
  {
    "origin": "A 0-1 mask that has the same size with I. This mask is used to ignore the effect of some pixels. If the pixel value on mask is 0, the pixel will be ignored when maintaining the joint-histogram. This is useful for applications like optical flow occlusion handling.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:49 for OpenCV by",
    "local": ""
  }
]