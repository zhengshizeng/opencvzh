[
  {
    "origin": "OpenCV: Arithm Operations on Matrices",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "Arithm Operations on Matrices",
    "local": ""
  },
  {
    "origin": "&raquo;",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Base class for convolution (or cross-correlation) operator. :",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Base class for",
    "local": ""
  },
  {
    "origin": "operator as a",
    "local": ""
  },
  {
    "origin": ". :",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "user_block_size=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Creates implementation for",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "dft_size, int flags)",
    "local": ""
  },
  {
    "origin": "Creates implementation for",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "&amp;stream=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1,",
    "local": ""
  },
  {
    "origin": "src2, double alpha,",
    "local": ""
  },
  {
    "origin": "src3, double beta,",
    "local": ""
  },
  {
    "origin": "&amp;stream=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Performs generalized matrix multiplication.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1,",
    "local": ""
  },
  {
    "origin": "src2,",
    "local": ""
  },
  {
    "origin": "dst, int flags, float scale, bool conjB=false,",
    "local": ""
  },
  {
    "origin": "&amp;stream=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Performs a per-element multiplication of two Fourier spectrums and scales the result.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1,",
    "local": ""
  },
  {
    "origin": "src2,",
    "local": ""
  },
  {
    "origin": "dst, int flags, bool conjB=false,",
    "local": ""
  },
  {
    "origin": "&amp;stream=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Performs a per-element multiplication of two Fourier spectrums.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "createConvolution()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::cuda::createConvolution",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "user_block_size",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates implementation for",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "user_block_size",
    "local": ""
  },
  {
    "origin": "Block size. If you leave default value Size(0,0) then automatic estimation of block size will be used (which is optimized for speed). By varying user_block_size you can reduce memory requirements at the cost of speed.",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "createDFT()",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::cuda::createDFT",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "dft_size",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates implementation for",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "dft_size",
    "local": ""
  },
  {
    "origin": "The image size.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "Optional flags:",
    "local": ""
  },
  {
    "origin": "DFT_ROWS",
    "local": ""
  },
  {
    "origin": "transforms each individual row of the source matrix.",
    "local": ""
  },
  {
    "origin": "DFT_SCALE",
    "local": ""
  },
  {
    "origin": "scales the result: divide it by the number of elements in the transform (obtained from dft_size ).",
    "local": ""
  },
  {
    "origin": "DFT_INVERSE",
    "local": ""
  },
  {
    "origin": "inverts",
    "local": ""
  },
  {
    "origin": ". Use for complex-complex cases (real-complex and complex-real cases are always forward and inverse, respectively).",
    "local": ""
  },
  {
    "origin": "DFT_COMPLEX_INPUT",
    "local": ""
  },
  {
    "origin": "Specifies that inputs will be complex with 2 channels.",
    "local": ""
  },
  {
    "origin": "DFT_REAL_OUTPUT",
    "local": ""
  },
  {
    "origin": "specifies the output as real. The source matrix is the result of real-complex transform, so the destination matrix must be real.",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "dft()",
    "local": ""
  },
  {
    "origin": "void cv::cuda::dft",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dft_size",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source matrix (real or complex).",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination matrix (real or complex).",
    "local": ""
  },
  {
    "origin": "dft_size",
    "local": ""
  },
  {
    "origin": "Size of a discrete Fourier transform.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "Optional flags:",
    "local": ""
  },
  {
    "origin": "DFT_ROWS",
    "local": ""
  },
  {
    "origin": "transforms each individual row of the source matrix.",
    "local": ""
  },
  {
    "origin": "DFT_SCALE",
    "local": ""
  },
  {
    "origin": "scales the result: divide it by the number of elements in the transform (obtained from dft_size ).",
    "local": ""
  },
  {
    "origin": "DFT_INVERSE",
    "local": ""
  },
  {
    "origin": "inverts",
    "local": ""
  },
  {
    "origin": ". Use for complex-complex cases (real-complex and complex-real cases are always forward and inverse, respectively).",
    "local": ""
  },
  {
    "origin": "DFT_COMPLEX_INPUT",
    "local": ""
  },
  {
    "origin": "Specifies that input is complex input with 2 channels.",
    "local": ""
  },
  {
    "origin": "DFT_REAL_OUTPUT",
    "local": ""
  },
  {
    "origin": "specifies the output as real. The source matrix is the result of real-complex transform, so the destination matrix must be real.",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "for the asynchronous version.",
    "local": ""
  },
  {
    "origin": "Use to handle real matrices ( CV32FC1 ) and complex matrices in the interleaved format ( CV32FC2 ).",
    "local": ""
  },
  {
    "origin": "The source matrix should be continuous, otherwise reallocation and data copying is performed. The function chooses an operation mode depending on the flags, size, and channel count of the source matrix:",
    "local": ""
  },
  {
    "origin": "If the source matrix is complex and the output is not specified as real, the destination matrix is complex and has the dft_size size and CV_32FC2 type. The destination matrix contains a full result of the",
    "local": ""
  },
  {
    "origin": "(forward or inverse).",
    "local": ""
  },
  {
    "origin": "If the source matrix is complex and the output is specified as real, the function assumes that its input is the result of the forward transform (see the next item). The destination matrix has the dft_size size and CV_32FC1 type. It contains the result of the inverse",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "If the source matrix is real (its type is CV_32FC1 ), forward",
    "local": ""
  },
  {
    "origin": "is performed. The result of the",
    "local": ""
  },
  {
    "origin": "is packed into complex ( CV_32FC2 ) matrix. So, the width of the destination matrix is dft_size.width / 2 + 1 . But if the source is a single column, the height is reduced instead of the width.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "gemm()",
    "local": ""
  },
  {
    "origin": "void cv::cuda::gemm",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "alpha",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "src3",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs generalized matrix multiplication.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "First multiplied input matrix that should have CV_32FC1 , CV_64FC1 , CV_32FC2 , or CV_64FC2 type.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "Second multiplied input matrix of the same type as src1 .",
    "local": ""
  },
  {
    "origin": "alpha",
    "local": ""
  },
  {
    "origin": "Weight of the matrix product.",
    "local": ""
  },
  {
    "origin": "src3",
    "local": ""
  },
  {
    "origin": "Third optional delta matrix added to the matrix product. It should have the same type as src1 and src2 .",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "Weight of src3 .",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination matrix. It has the proper size and the same type as input matrices.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "Operation flags:",
    "local": ""
  },
  {
    "origin": "GEMM_1_T",
    "local": ""
  },
  {
    "origin": "transpose src1",
    "local": ""
  },
  {
    "origin": "GEMM_2_T",
    "local": ""
  },
  {
    "origin": "transpose src2",
    "local": ""
  },
  {
    "origin": "GEMM_3_T",
    "local": ""
  },
  {
    "origin": "transpose src3",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "for the asynchronous version.",
    "local": ""
  },
  {
    "origin": "The function performs generalized matrix multiplication similar to the gemm functions in BLAS level",
    "local": ""
  },
  {
    "origin": "For example, gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} = \\texttt{alpha} \\cdot \\texttt{src1} ^T \\cdot \\texttt{src2} + \\texttt{beta} \\cdot \\texttt{src3} ^T\\]",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Transposition operation doesn't support CV_64FC2 input type.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "mulAndScaleSpectrums()",
    "local": ""
  },
  {
    "origin": "void cv::cuda::mulAndScaleSpectrums",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "conjB",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs a per-element multiplication of two Fourier spectrums and scales the result.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "First spectrum.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "Second spectrum with the same size and type as a .",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination spectrum.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "Mock parameter used for CPU/CUDA interfaces similarity, simply add a",
    "local": ""
  },
  {
    "origin": "value.",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "Scale constant.",
    "local": ""
  },
  {
    "origin": "conjB",
    "local": ""
  },
  {
    "origin": "Optional flag to specify if the second spectrum needs to be conjugated before the multiplication.",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "for the asynchronous version.",
    "local": ""
  },
  {
    "origin": "Only full (not packed) CV_32FC2 complex spectrums in the interleaved format are supported for now.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "mulSpectrums()",
    "local": ""
  },
  {
    "origin": "void cv::cuda::mulSpectrums",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "conjB",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs a per-element multiplication of two Fourier spectrums.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "First spectrum.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "Second spectrum with the same size and type as a .",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination spectrum.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "Mock parameter used for CPU/CUDA interfaces similarity.",
    "local": ""
  },
  {
    "origin": "conjB",
    "local": ""
  },
  {
    "origin": "Optional flag to specify if the second spectrum needs to be conjugated before the multiplication.",
    "local": ""
  },
  {
    "origin": "stream",
    "local": ""
  },
  {
    "origin": "for the asynchronous version.",
    "local": ""
  },
  {
    "origin": "Only full (not packed) CV_32FC2 complex spectrums in the interleaved format are supported for now.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:41 for OpenCV by &#160;",
    "local": ""
  }
]