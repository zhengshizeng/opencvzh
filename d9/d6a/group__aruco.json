[
  {
    "origin": "OpenCV: ArUco Marker Detection",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "ArUco Marker Detection",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "of markers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "ChArUco board Specific class for ChArUco boards. A ChArUco board is a planar board where the markers are placed inside the white squares of a chessboard. The benefits of ChArUco boards is that they provide both, ArUco markers versatility and chessboard corner precision, which is important for calibration and pose estimation. This class also allows the easy creation and drawing of ChArUco boards.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "struct",
    "local": ""
  },
  {
    "origin": "Parameters for the detectMarker process:",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Dictionary/Set of markers. It contains the inner codification.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Planar board with grid arrangement of markers More common type of board. All markers are placed in the same plane in a grid arrangement. The board can be drawn using",
    "local": ""
  },
  {
    "origin": "function (.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Predefined markers dictionaries/sets Each dictionary indicates the number of bits and the number of markers contained.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "*board,",
    "local": ""
  },
  {
    "origin": "outSize,",
    "local": ""
  },
  {
    "origin": "img, int marginSize=0, int borderBits=1)",
    "local": ""
  },
  {
    "origin": "Implementation of drawPlanarBoard that accepts a raw",
    "local": ""
  },
  {
    "origin": "pointer.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners,",
    "local": ""
  },
  {
    "origin": "ids,",
    "local": ""
  },
  {
    "origin": "counter, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "imageSize,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvecs,",
    "local": ""
  },
  {
    "origin": "tvecs,",
    "local": ""
  },
  {
    "origin": "stdDeviationsIntrinsics,",
    "local": ""
  },
  {
    "origin": "stdDeviationsExtrinsics,",
    "local": ""
  },
  {
    "origin": "criteria=",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "+",
    "local": ""
  },
  {
    "origin": ", 30, DBL_EPSILON))",
    "local": ""
  },
  {
    "origin": "Calibrate a camera using aruco markers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners,",
    "local": ""
  },
  {
    "origin": "ids,",
    "local": ""
  },
  {
    "origin": "counter, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "imageSize,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvecs=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "tvecs=",
    "local": ""
  },
  {
    "origin": "criteria=",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "+",
    "local": ""
  },
  {
    "origin": ", 30, DBL_EPSILON))",
    "local": ""
  },
  {
    "origin": "It's the same function as",
    "local": ""
  },
  {
    "origin": "but without calibration error estimation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "charucoCorners,",
    "local": ""
  },
  {
    "origin": "charucoIds, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "imageSize,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvecs,",
    "local": ""
  },
  {
    "origin": "tvecs,",
    "local": ""
  },
  {
    "origin": "stdDeviationsIntrinsics,",
    "local": ""
  },
  {
    "origin": "stdDeviationsExtrinsics,",
    "local": ""
  },
  {
    "origin": "criteria=",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "+",
    "local": ""
  },
  {
    "origin": ", 30, DBL_EPSILON))",
    "local": ""
  },
  {
    "origin": "Calibrate a camera using Charuco corners.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "charucoCorners,",
    "local": ""
  },
  {
    "origin": "charucoIds, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "imageSize,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvecs=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "tvecs=",
    "local": ""
  },
  {
    "origin": "criteria=",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "+",
    "local": ""
  },
  {
    "origin": ", 30, DBL_EPSILON))",
    "local": ""
  },
  {
    "origin": "It's the same function as",
    "local": ""
  },
  {
    "origin": "but without calibration error estimation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "markerCorners,",
    "local": ""
  },
  {
    "origin": "markerIds, float squareMarkerLengthRate,",
    "local": ""
  },
  {
    "origin": "diamondCorners,",
    "local": ""
  },
  {
    "origin": "diamondIds,",
    "local": ""
  },
  {
    "origin": "cameraMatrix=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "distCoeffs=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Detect ChArUco Diamond markers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;dictionary,",
    "local": ""
  },
  {
    "origin": "corners,",
    "local": ""
  },
  {
    "origin": "ids, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;parameters=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "rejectedImgPoints=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "cameraMatrix=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "distCoeff=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Basic marker detection.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvec,",
    "local": ""
  },
  {
    "origin": "tvec, float length)",
    "local": ""
  },
  {
    "origin": "Draw coordinate system axis from pose estimation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;dictionary,",
    "local": ""
  },
  {
    "origin": "ids, int squareLength, int markerLength,",
    "local": ""
  },
  {
    "origin": "img, int marginSize=0, int borderBits=1)",
    "local": ""
  },
  {
    "origin": "Draw a ChArUco Diamond marker.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "charucoCorners,",
    "local": ""
  },
  {
    "origin": "charucoIds=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "cornerColor=",
    "local": ""
  },
  {
    "origin": "(255, 0, 0))",
    "local": ""
  },
  {
    "origin": "Draws a set of Charuco corners.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "diamondCorners,",
    "local": ""
  },
  {
    "origin": "diamondIds=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "borderColor=",
    "local": ""
  },
  {
    "origin": "(0, 0, 255))",
    "local": ""
  },
  {
    "origin": "Draw a set of detected ChArUco Diamond markers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "corners,",
    "local": ""
  },
  {
    "origin": "ids=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "borderColor=",
    "local": ""
  },
  {
    "origin": "(0, 255, 0))",
    "local": ""
  },
  {
    "origin": "Draw detected markers in image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;dictionary, int id, int sidePixels,",
    "local": ""
  },
  {
    "origin": "img, int borderBits=1)",
    "local": ""
  },
  {
    "origin": "Draw a canonical marker image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "outSize,",
    "local": ""
  },
  {
    "origin": "img, int marginSize=0, int borderBits=1)",
    "local": ""
  },
  {
    "origin": "Draw a planar board.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners,",
    "local": ""
  },
  {
    "origin": "ids, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvec,",
    "local": ""
  },
  {
    "origin": "tvec, bool useExtrinsicGuess=false)",
    "local": ""
  },
  {
    "origin": "Pose estimation for a board of markers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "charucoCorners,",
    "local": ""
  },
  {
    "origin": "charucoIds, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvec,",
    "local": ""
  },
  {
    "origin": "tvec, bool useExtrinsicGuess=false)",
    "local": ""
  },
  {
    "origin": "Pose estimation for a ChArUco board given some of their corners.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners, float markerLength,",
    "local": ""
  },
  {
    "origin": "cameraMatrix,",
    "local": ""
  },
  {
    "origin": "distCoeffs,",
    "local": ""
  },
  {
    "origin": "rvecs,",
    "local": ""
  },
  {
    "origin": "tvecs,",
    "local": ""
  },
  {
    "origin": "_objPoints=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Pose estimation for single markers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(int nMarkers, int markerSize, int randomSeed=0)",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(int nMarkers, int markerSize, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;baseDictionary, int randomSeed=0)",
    "local": ""
  },
  {
    "origin": "Generates a new customizable marker dictionary.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "detectedCorners,",
    "local": ""
  },
  {
    "origin": "detectedIds,",
    "local": ""
  },
  {
    "origin": "objPoints,",
    "local": ""
  },
  {
    "origin": "imgPoints)",
    "local": ""
  },
  {
    "origin": "Given a board configuration and a set of detected markers, returns the corresponding image points and object points to call solvePnP.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "name)",
    "local": ""
  },
  {
    "origin": "Returns one of the predefined dictionaries defined in PREDEFINED_DICTIONARY_NAME.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(int dict)",
    "local": ""
  },
  {
    "origin": "Returns one of the predefined dictionaries referenced by DICT_*.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "markerCorners,",
    "local": ""
  },
  {
    "origin": "markerIds,",
    "local": ""
  },
  {
    "origin": "image, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "charucoCorners,",
    "local": ""
  },
  {
    "origin": "charucoIds,",
    "local": ""
  },
  {
    "origin": "cameraMatrix=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "distCoeffs=",
    "local": ""
  },
  {
    "origin": "(), int minMarkers=2)",
    "local": ""
  },
  {
    "origin": "Interpolate position of ChArUco board corners.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image, const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;board,",
    "local": ""
  },
  {
    "origin": "detectedCorners,",
    "local": ""
  },
  {
    "origin": "detectedIds,",
    "local": ""
  },
  {
    "origin": "rejectedCorners,",
    "local": ""
  },
  {
    "origin": "cameraMatrix=",
    "local": ""
  },
  {
    "origin": "(),",
    "local": ""
  },
  {
    "origin": "distCoeffs=",
    "local": ""
  },
  {
    "origin": "(), float minRepDistance=10.f, float errorCorrectionRate=3.f, bool checkAllOrders=true,",
    "local": ""
  },
  {
    "origin": "recoveredIdxs=",
    "local": ""
  },
  {
    "origin": "(), const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;parameters=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Refind not detected markers based on the already detected and the board layout.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;_board,",
    "local": ""
  },
  {
    "origin": "_charucoIds)",
    "local": ""
  },
  {
    "origin": "test whether the ChArUco markers are collinear",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "This module is dedicated to square fiducial markers (also known as Augmented Reality Markers) These markers are useful for easy, fast and robust camera pose estimation.ç",
    "local": ""
  },
  {
    "origin": "The main functionalities are:",
    "local": ""
  },
  {
    "origin": "Detection of markers in an image",
    "local": ""
  },
  {
    "origin": "Pose estimation from a single marker or from a board/set of markers",
    "local": ""
  },
  {
    "origin": "Detection of ChArUco board for high subpixel accuracy",
    "local": ""
  },
  {
    "origin": "Camera calibration from both, ArUco boards and ChArUco boards.",
    "local": ""
  },
  {
    "origin": "Detection of ChArUco diamond markers The samples directory includes easy examples of how to use the module.",
    "local": ""
  },
  {
    "origin": "The implementation is based on the ArUco Library by R. Muñoz-Salinas and S. Garrido-Jurado",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "fiducial detection method.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "S. Garrido-Jurado, R. Muñoz-Salinas, F. J. Madrid-Cuevas, and M. J. Marín-Jiménez. 2014. \"Automatic generation and detection of highly reliable fiducial markers under occlusion\". Pattern Recogn. 47, 6 (June 2014), 2280-2292. DOI=10.1016/j.patcog.2014.01.005",
    "local": ""
  },
  {
    "origin": "http://www.uco.es/investiga/grupos/ava/node/26",
    "local": ""
  },
  {
    "origin": "Enumeration Type Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "CornerRefineMethod",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "CORNER_REFINE_NONE",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.CORNER_REFINE_NONE",
    "local": ""
  },
  {
    "origin": "Tag and corners detection based on the ArUco approach.",
    "local": ""
  },
  {
    "origin": "CORNER_REFINE_SUBPIX",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.CORNER_REFINE_SUBPIX",
    "local": ""
  },
  {
    "origin": "ArUco approach and refine the corners locations using corner subpixel accuracy.",
    "local": ""
  },
  {
    "origin": "CORNER_REFINE_CONTOUR",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.CORNER_REFINE_CONTOUR",
    "local": ""
  },
  {
    "origin": "ArUco approach and refine the corners locations using the contour-points line fitting.",
    "local": ""
  },
  {
    "origin": "CORNER_REFINE_APRILTAG",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.CORNER_REFINE_APRILTAG",
    "local": ""
  },
  {
    "origin": "Tag and corners detection based on the AprilTag 2 approach",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "PREDEFINED_DICTIONARY_NAME",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Predefined markers dictionaries/sets Each dictionary indicates the number of bits and the number of markers contained.",
    "local": ""
  },
  {
    "origin": "DICT_ARUCO_ORIGINAL: standard ArUco Library Markers. 1024 markers, 5x5 bits, 0 minimum distance",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "DICT_4X4_50",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_4X4_50",
    "local": ""
  },
  {
    "origin": "DICT_4X4_100",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_4X4_100",
    "local": ""
  },
  {
    "origin": "DICT_4X4_250",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_4X4_250",
    "local": ""
  },
  {
    "origin": "DICT_4X4_1000",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_4X4_1000",
    "local": ""
  },
  {
    "origin": "DICT_5X5_50",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_5X5_50",
    "local": ""
  },
  {
    "origin": "DICT_5X5_100",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_5X5_100",
    "local": ""
  },
  {
    "origin": "DICT_5X5_250",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_5X5_250",
    "local": ""
  },
  {
    "origin": "DICT_5X5_1000",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_5X5_1000",
    "local": ""
  },
  {
    "origin": "DICT_6X6_50",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_6X6_50",
    "local": ""
  },
  {
    "origin": "DICT_6X6_100",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_6X6_100",
    "local": ""
  },
  {
    "origin": "DICT_6X6_250",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_6X6_250",
    "local": ""
  },
  {
    "origin": "DICT_6X6_1000",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_6X6_1000",
    "local": ""
  },
  {
    "origin": "DICT_7X7_50",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_7X7_50",
    "local": ""
  },
  {
    "origin": "DICT_7X7_100",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_7X7_100",
    "local": ""
  },
  {
    "origin": "DICT_7X7_250",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_7X7_250",
    "local": ""
  },
  {
    "origin": "DICT_7X7_1000",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_7X7_1000",
    "local": ""
  },
  {
    "origin": "DICT_ARUCO_ORIGINAL",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_ARUCO_ORIGINAL",
    "local": ""
  },
  {
    "origin": "DICT_APRILTAG_16h5",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_APRILTAG_16h5",
    "local": ""
  },
  {
    "origin": "4x4 bits, minimum hamming distance between any two codes = 5, 30 codes",
    "local": ""
  },
  {
    "origin": "DICT_APRILTAG_25h9",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_APRILTAG_25h9",
    "local": ""
  },
  {
    "origin": "5x5 bits, minimum hamming distance between any two codes = 9, 35 codes",
    "local": ""
  },
  {
    "origin": "DICT_APRILTAG_36h10",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_APRILTAG_36h10",
    "local": ""
  },
  {
    "origin": "6x6 bits, minimum hamming distance between any two codes = 10, 2320 codes",
    "local": ""
  },
  {
    "origin": "DICT_APRILTAG_36h11",
    "local": ""
  },
  {
    "origin": "Python: cv.aruco.DICT_APRILTAG_36h11",
    "local": ""
  },
  {
    "origin": "6x6 bits, minimum hamming distance between any two codes = 11, 587 codes",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "_drawPlanarBoardImpl()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::_drawPlanarBoardImpl",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "*",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "outSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "marginSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Implementation of drawPlanarBoard that accepts a raw",
    "local": ""
  },
  {
    "origin": "pointer.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "calibrateCameraAruco()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "double cv::aruco::calibrateCameraAruco",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "counter",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "imageSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stdDeviationsIntrinsics",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stdDeviationsExtrinsics",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "perViewErrors",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "criteria",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraAruco(",
    "local": ""
  },
  {
    "origin": "corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraArucoExtended(",
    "local": ""
  },
  {
    "origin": "corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calibrate a camera using aruco markers.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": "vector of detected marker corners in all frames. The corners should have the same format returned by detectMarkers (see",
    "local": ""
  },
  {
    "origin": ").",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": "list of identifiers for each marker in corners",
    "local": ""
  },
  {
    "origin": "counter",
    "local": ""
  },
  {
    "origin": "number of markers in each frame so that corners and ids can be split",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "Marker",
    "local": ""
  },
  {
    "origin": "layout",
    "local": ""
  },
  {
    "origin": "imageSize",
    "local": ""
  },
  {
    "origin": "Size of the image used only to initialize the intrinsic camera matrix.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "Output 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\) . If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be initialized before calling the function.",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "Output vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": "Output vector of rotation vectors (see Rodrigues ) estimated for each board view (e.g. std::vector&lt;cv::Mat&gt;&gt;). That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the board pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the board pattern in the k-th pattern view (k=0..",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "-1).",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": "Output vector of translation vectors estimated for each pattern view.",
    "local": ""
  },
  {
    "origin": "stdDeviationsIntrinsics",
    "local": ""
  },
  {
    "origin": "Output vector of standard deviations estimated for intrinsic parameters. Order of deviations values: \\((f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3, s_4, \\tau_x, \\tau_y)\\) If one of parameters is not estimated, it's deviation is equals to zero.",
    "local": ""
  },
  {
    "origin": "stdDeviationsExtrinsics",
    "local": ""
  },
  {
    "origin": "Output vector of standard deviations estimated for extrinsic parameters. Order of deviations values: \\((R_1, T_1, \\dotsc , R_M, T_M)\\) where M is number of pattern views, \\(R_i, T_i\\) are concatenated 1x3 vectors.",
    "local": ""
  },
  {
    "origin": "perViewErrors",
    "local": ""
  },
  {
    "origin": "Output vector of average re-projection errors estimated for each pattern view.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "flags Different flags for the calibration process (see",
    "local": ""
  },
  {
    "origin": "for details).",
    "local": ""
  },
  {
    "origin": "criteria",
    "local": ""
  },
  {
    "origin": "Termination criteria for the iterative optimization algorithm.",
    "local": ""
  },
  {
    "origin": "This function calibrates a camera using an Aruco",
    "local": ""
  },
  {
    "origin": ". The function receives a list of detected markers from several views of the",
    "local": ""
  },
  {
    "origin": ". The process is similar to the chessboard calibration in",
    "local": ""
  },
  {
    "origin": ". The function returns the final re-projection error.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "calibrateCameraAruco()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "double cv::aruco::calibrateCameraAruco",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "counter",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "imageSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "criteria",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraAruco(",
    "local": ""
  },
  {
    "origin": "corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraArucoExtended(",
    "local": ""
  },
  {
    "origin": "corners, ids, counter, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "It's the same function as",
    "local": ""
  },
  {
    "origin": "but without calibration error estimation.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "calibrateCameraCharuco()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "double cv::aruco::calibrateCameraCharuco",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "imageSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stdDeviationsIntrinsics",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "stdDeviationsExtrinsics",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "perViewErrors",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "criteria",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraCharuco(",
    "local": ""
  },
  {
    "origin": "charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraCharucoExtended(",
    "local": ""
  },
  {
    "origin": "charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calibrate a camera using Charuco corners.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": "vector of detected charuco corners per frame",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": "list of identifiers for each corner in charucoCorners per frame",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "Marker",
    "local": ""
  },
  {
    "origin": "layout",
    "local": ""
  },
  {
    "origin": "imageSize",
    "local": ""
  },
  {
    "origin": "input image size",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "Output 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\) . If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be initialized before calling the function.",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "Output vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": "Output vector of rotation vectors (see Rodrigues ) estimated for each board view (e.g. std::vector&lt;cv::Mat&gt;&gt;). That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the board pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the board pattern in the k-th pattern view (k=0..",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "-1).",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": "Output vector of translation vectors estimated for each pattern view.",
    "local": ""
  },
  {
    "origin": "stdDeviationsIntrinsics",
    "local": ""
  },
  {
    "origin": "Output vector of standard deviations estimated for intrinsic parameters. Order of deviations values: \\((f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3, s_4, \\tau_x, \\tau_y)\\) If one of parameters is not estimated, it's deviation is equals to zero.",
    "local": ""
  },
  {
    "origin": "stdDeviationsExtrinsics",
    "local": ""
  },
  {
    "origin": "Output vector of standard deviations estimated for extrinsic parameters. Order of deviations values: \\((R_1, T_1, \\dotsc , R_M, T_M)\\) where M is number of pattern views, \\(R_i, T_i\\) are concatenated 1x3 vectors.",
    "local": ""
  },
  {
    "origin": "perViewErrors",
    "local": ""
  },
  {
    "origin": "Output vector of average re-projection errors estimated for each pattern view.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "flags Different flags for the calibration process (see",
    "local": ""
  },
  {
    "origin": "for details).",
    "local": ""
  },
  {
    "origin": "criteria",
    "local": ""
  },
  {
    "origin": "Termination criteria for the iterative optimization algorithm.",
    "local": ""
  },
  {
    "origin": "This function calibrates a camera using a set of corners of a Charuco",
    "local": ""
  },
  {
    "origin": ". The function receives a list of detected corners and its identifiers from several views of the",
    "local": ""
  },
  {
    "origin": ". The function returns the final re-projection error.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "calibrateCameraCharuco()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "double cv::aruco::calibrateCameraCharuco",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "imageSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "criteria",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraCharuco(",
    "local": ""
  },
  {
    "origin": "charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.calibrateCameraCharucoExtended(",
    "local": ""
  },
  {
    "origin": "charucoCorners, charucoIds, board, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, stdDeviationsIntrinsics[, stdDeviationsExtrinsics[, perViewErrors[, flags[, criteria]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "It's the same function as",
    "local": ""
  },
  {
    "origin": "but without calibration error estimation.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "detectCharucoDiamond()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::detectCharucoDiamond",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "markerCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "markerIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "squareMarkerLengthRate",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "diamondCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "diamondIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "diamondCorners, diamondIds",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.detectCharucoDiamond(",
    "local": ""
  },
  {
    "origin": "image, markerCorners, markerIds, squareMarkerLengthRate[, diamondCorners[, diamondIds[, cameraMatrix[, distCoeffs]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Detect ChArUco Diamond markers.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input image necessary for corner subpixel.",
    "local": ""
  },
  {
    "origin": "markerCorners",
    "local": ""
  },
  {
    "origin": "list of detected marker corners from detectMarkers function.",
    "local": ""
  },
  {
    "origin": "markerIds",
    "local": ""
  },
  {
    "origin": "list of marker ids in markerCorners.",
    "local": ""
  },
  {
    "origin": "squareMarkerLengthRate",
    "local": ""
  },
  {
    "origin": "rate between square and marker length: squareMarkerLengthRate = squareLength/markerLength. The real units are not necessary.",
    "local": ""
  },
  {
    "origin": "diamondCorners",
    "local": ""
  },
  {
    "origin": "output list of detected diamond corners (4 corners per diamond). The order is the same than in marker corners: top left, top right, bottom right and bottom left. Similar format than the corners returned by detectMarkers (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ).",
    "local": ""
  },
  {
    "origin": "diamondIds",
    "local": ""
  },
  {
    "origin": "ids of the diamonds in diamondCorners. The id of each diamond is in fact of type Vec4i, so each diamond has 4 ids, which are the ids of the aruco markers composing the diamond.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "Optional camera calibration matrix.",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "Optional camera distortion coefficients.",
    "local": ""
  },
  {
    "origin": "This function detects Diamond markers from the previous detected ArUco markers. The diamonds are returned in the diamondCorners and diamondIds parameters. If camera calibration parameters are provided, the diamond search is based on reprojection. If not, diamond search is based on homography. Homography is faster than reprojection but can slightly reduce the detection rate.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "detectMarkers()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::detectMarkers",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "dictionary",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "parameters",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rejectedImgPoints",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeff",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "corners, ids, rejectedImgPoints",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.detectMarkers(",
    "local": ""
  },
  {
    "origin": "image, dictionary[, corners[, ids[, parameters[, rejectedImgPoints[, cameraMatrix[, distCoeff]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Basic marker detection.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input image",
    "local": ""
  },
  {
    "origin": "dictionary",
    "local": ""
  },
  {
    "origin": "indicates the type of markers that will be searched",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": "vector of detected marker corners. For each marker, its four corners are provided, (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array is Nx4. The order of the corners is clockwise.",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": "vector of identifiers of the detected markers. The identifier is of type int (e.g. std::vector&lt;int&gt;). For N detected markers, the size of ids is also N. The identifiers have the same order than the markers in the imgPoints array.",
    "local": ""
  },
  {
    "origin": "parameters",
    "local": ""
  },
  {
    "origin": "marker detection parameters",
    "local": ""
  },
  {
    "origin": "rejectedImgPoints",
    "local": ""
  },
  {
    "origin": "contains the imgPoints of those squares whose inner code has not a correct codification. Useful for debugging purposes.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "optional input 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeff",
    "local": ""
  },
  {
    "origin": "optional vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "Performs marker detection in the input image. Only markers included in the specific dictionary are searched. For each detected marker, it returns the 2D position of its corner in the image and its corresponding identifier. Note that this function does not perform pose estimation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawAxis()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawAxis",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "length",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.drawAxis(",
    "local": ""
  },
  {
    "origin": "image, cameraMatrix, distCoeffs, rvec, tvec, length",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draw coordinate system axis from pose estimation.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input/output image. It must have 1 or 3 channels. The number of channels is not altered.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "input 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": "rotation vector of the coordinate system that will be drawn. (",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ").",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": "translation vector of the coordinate system that will be drawn.",
    "local": ""
  },
  {
    "origin": "length",
    "local": ""
  },
  {
    "origin": "length of the painted axis in the same unit than tvec (usually in meters)",
    "local": ""
  },
  {
    "origin": "Given the pose estimation of a marker or board, this function draws the axis of the world coordinate system, i.e. the system centered on the marker/board. Useful for debugging purposes.",
    "local": ""
  },
  {
    "origin": "use",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawCharucoDiamond()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawCharucoDiamond",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "dictionary",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "squareLength",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "markerLength",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "marginSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draw a ChArUco Diamond marker.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "dictionary",
    "local": ""
  },
  {
    "origin": "dictionary of markers indicating the type of markers.",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": "list of 4 ids for each ArUco marker in the ChArUco marker.",
    "local": ""
  },
  {
    "origin": "squareLength",
    "local": ""
  },
  {
    "origin": "size of the chessboard squares in pixels.",
    "local": ""
  },
  {
    "origin": "markerLength",
    "local": ""
  },
  {
    "origin": "size of the markers in pixels.",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": "output image with the marker. The size of this image will be 3*squareLength + 2*marginSize,.",
    "local": ""
  },
  {
    "origin": "marginSize",
    "local": ""
  },
  {
    "origin": "minimum margins (in pixels) of the marker in the output image",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "width of the marker borders.",
    "local": ""
  },
  {
    "origin": "This function return the image of a ChArUco marker, ready to be printed.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawDetectedCornersCharuco()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawDetectedCornersCharuco",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cornerColor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.drawDetectedCornersCharuco(",
    "local": ""
  },
  {
    "origin": "image, charucoCorners[, charucoIds[, cornerColor]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draws a set of Charuco corners.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input/output image. It must have 1 or 3 channels. The number of channels is not altered.",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": "vector of detected charuco corners",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": "list of identifiers for each corner in charucoCorners",
    "local": ""
  },
  {
    "origin": "cornerColor",
    "local": ""
  },
  {
    "origin": "color of the square surrounding each corner",
    "local": ""
  },
  {
    "origin": "This function draws a set of detected Charuco corners. If identifiers vector is provided, it also draws the id of each corner.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawDetectedDiamonds()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawDetectedDiamonds",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "diamondCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "diamondIds",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "borderColor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.drawDetectedDiamonds(",
    "local": ""
  },
  {
    "origin": "image, diamondCorners[, diamondIds[, borderColor]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draw a set of detected ChArUco Diamond markers.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input/output image. It must have 1 or 3 channels. The number of channels is not altered.",
    "local": ""
  },
  {
    "origin": "diamondCorners",
    "local": ""
  },
  {
    "origin": "positions of diamond corners in the same format returned by",
    "local": ""
  },
  {
    "origin": ". (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.",
    "local": ""
  },
  {
    "origin": "diamondIds",
    "local": ""
  },
  {
    "origin": "vector of identifiers for diamonds in diamondCorners, in the same format returned by",
    "local": ""
  },
  {
    "origin": "(e.g. std::vector&lt;Vec4i&gt;). Optional, if not provided, ids are not painted.",
    "local": ""
  },
  {
    "origin": "borderColor",
    "local": ""
  },
  {
    "origin": "color of marker borders. Rest of colors (text color and first corner color) are calculated based on this one.",
    "local": ""
  },
  {
    "origin": "Given an array of detected diamonds, this functions draws them in the image. The marker borders are painted and the markers identifiers if provided. Useful for debugging purposes.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawDetectedMarkers()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawDetectedMarkers",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "borderColor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.drawDetectedMarkers(",
    "local": ""
  },
  {
    "origin": "image, corners[, ids[, borderColor]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draw detected markers in image.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input/output image. It must have 1 or 3 channels. The number of channels is not altered.",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": "positions of marker corners on input image. (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": "vector of identifiers for markers in markersCorners . Optional, if not provided, ids are not painted.",
    "local": ""
  },
  {
    "origin": "borderColor",
    "local": ""
  },
  {
    "origin": "color of marker borders. Rest of colors (text color and first corner color) are calculated based on this one to improve visualization.",
    "local": ""
  },
  {
    "origin": "Given an array of detected marker corners and its corresponding ids, this functions draws the markers in the image. The marker borders are painted and the markers identifiers if provided. Useful for debugging purposes.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawMarker()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawMarker",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "dictionary",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "id",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "sidePixels",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.drawMarker(",
    "local": ""
  },
  {
    "origin": "dictionary, id, sidePixels[, img[, borderBits]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draw a canonical marker image.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "dictionary",
    "local": ""
  },
  {
    "origin": "dictionary of markers indicating the type of markers",
    "local": ""
  },
  {
    "origin": "id",
    "local": ""
  },
  {
    "origin": "identifier of the marker that will be returned. It has to be a valid id in the specified dictionary.",
    "local": ""
  },
  {
    "origin": "sidePixels",
    "local": ""
  },
  {
    "origin": "size of the image in pixels",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": "output image with the marker",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "width of the marker border.",
    "local": ""
  },
  {
    "origin": "This function returns a marker image in its canonical form (i.e. ready to be printed)",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "drawPlanarBoard()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::drawPlanarBoard",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "outSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "marginSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.drawPlanarBoard(",
    "local": ""
  },
  {
    "origin": "board, outSize[, img[, marginSize[, borderBits]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Draw a planar board.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "layout of the board that will be drawn. The board should be planar, z coordinate is ignored",
    "local": ""
  },
  {
    "origin": "outSize",
    "local": ""
  },
  {
    "origin": "size of the output image in pixels.",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": "output image with the board. The size of this image will be outSize and the board will be on the center, keeping the board proportions.",
    "local": ""
  },
  {
    "origin": "marginSize",
    "local": ""
  },
  {
    "origin": "minimum margins (in pixels) of the board in the output image",
    "local": ""
  },
  {
    "origin": "borderBits",
    "local": ""
  },
  {
    "origin": "width of the marker borders.",
    "local": ""
  },
  {
    "origin": "This function return the image of a planar board, ready to be printed. It assumes the",
    "local": ""
  },
  {
    "origin": "layout specified is planar by ignoring the z coordinates of the object points.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "estimatePoseBoard()",
    "local": ""
  },
  {
    "origin": "int cv::aruco::estimatePoseBoard",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "useExtrinsicGuess",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, rvec, tvec",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.estimatePoseBoard(",
    "local": ""
  },
  {
    "origin": "corners, ids, board, cameraMatrix, distCoeffs, rvec, tvec[, useExtrinsicGuess]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Pose estimation for a board of markers.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": "vector of already detected markers corners. For each marker, its four corners are provided, (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.",
    "local": ""
  },
  {
    "origin": "ids",
    "local": ""
  },
  {
    "origin": "list of identifiers for each marker in corners",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "layout of markers in the board. The layout is composed by the marker identifiers and the positions of each marker corner in the board reference system.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "input 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": "Output vector (e.g.",
    "local": ""
  },
  {
    "origin": ") corresponding to the rotation vector of the board (see",
    "local": ""
  },
  {
    "origin": "). Used as initial guess if not empty.",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": "Output vector (e.g.",
    "local": ""
  },
  {
    "origin": ") corresponding to the translation vector of the board.",
    "local": ""
  },
  {
    "origin": "useExtrinsicGuess",
    "local": ""
  },
  {
    "origin": "defines whether initial guess for",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": "will be used or not. Used as initial guess if not empty.",
    "local": ""
  },
  {
    "origin": "This function receives the detected markers and returns the pose of a marker board composed by those markers. A",
    "local": ""
  },
  {
    "origin": "of marker has a single world coordinate system which is defined by the board layout. The returned transformation is the one that transforms points from the board coordinate system to the camera coordinate system. Input markers that are not included in the board layout are ignored. The function returns the number of markers from the input employed for the board pose estimation. Note that returning a 0 means the pose has not been estimated.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "estimatePoseCharucoBoard()",
    "local": ""
  },
  {
    "origin": "bool cv::aruco::estimatePoseCharucoBoard",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "useExtrinsicGuess",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, rvec, tvec",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.estimatePoseCharucoBoard(",
    "local": ""
  },
  {
    "origin": "charucoCorners, charucoIds, board, cameraMatrix, distCoeffs, rvec, tvec[, useExtrinsicGuess]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Pose estimation for a ChArUco board given some of their corners.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": "vector of detected charuco corners",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": "list of identifiers for each corner in charucoCorners",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "layout of ChArUco board.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "input 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": "Output vector (e.g.",
    "local": ""
  },
  {
    "origin": ") corresponding to the rotation vector of the board (see",
    "local": ""
  },
  {
    "origin": ").",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": "Output vector (e.g.",
    "local": ""
  },
  {
    "origin": ") corresponding to the translation vector of the board.",
    "local": ""
  },
  {
    "origin": "useExtrinsicGuess",
    "local": ""
  },
  {
    "origin": "defines whether initial guess for",
    "local": ""
  },
  {
    "origin": "rvec",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "tvec",
    "local": ""
  },
  {
    "origin": "will be used or not.",
    "local": ""
  },
  {
    "origin": "This function estimates a Charuco board pose from some detected corners. The function checks if the input corners are enough and valid to perform pose estimation. If pose estimation is valid, returns true, else returns false.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "estimatePoseSingleMarkers()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::estimatePoseSingleMarkers",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "markerLength",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "_objPoints",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "rvecs, tvecs, _objPoints",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.estimatePoseSingleMarkers(",
    "local": ""
  },
  {
    "origin": "corners, markerLength, cameraMatrix, distCoeffs[, rvecs[, tvecs[, _objPoints]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Pose estimation for single markers.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "corners",
    "local": ""
  },
  {
    "origin": "vector of already detected markers corners. For each marker, its four corners are provided, (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "markerLength",
    "local": ""
  },
  {
    "origin": "the length of the markers' side. The returning translation vectors will be in the same unit. Normally, unit is meters.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "input 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "rvecs",
    "local": ""
  },
  {
    "origin": "array of output rotation vectors (",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ") (e.g. std::vector&lt;cv::Vec3d&gt;). Each element in rvecs corresponds to the specific marker in imgPoints.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "tvecs",
    "local": ""
  },
  {
    "origin": "array of output translation vectors (e.g. std::vector&lt;cv::Vec3d&gt;). Each element in tvecs corresponds to the specific marker in imgPoints.",
    "local": ""
  },
  {
    "origin": "_objPoints",
    "local": ""
  },
  {
    "origin": "array of object points of all the marker corners",
    "local": ""
  },
  {
    "origin": "This function receives the detected markers and returns their pose estimation respect to the camera individually. So for each marker, one rotation and translation vector is returned. The returned transformation is the one that transforms points from each marker coordinate system to the camera coordinate system. The marker corrdinate system is centered on the middle of the marker, with the Z axis perpendicular to the marker plane. The coordinates of the four corners of the marker in its own coordinate system are: (-markerLength/2, markerLength/2, 0), (markerLength/2, markerLength/2, 0), (markerLength/2, -markerLength/2, 0), (-markerLength/2, -markerLength/2, 0)",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "generateCustomDictionary()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::aruco::generateCustomDictionary",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "nMarkers",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "markerSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "randomSeed",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.custom_dictionary(",
    "local": ""
  },
  {
    "origin": "nMarkers, markerSize[, randomSeed]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.custom_dictionary_from(",
    "local": ""
  },
  {
    "origin": "nMarkers, markerSize, baseDictionary[, randomSeed]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "generateCustomDictionary()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::aruco::generateCustomDictionary",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "nMarkers",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "markerSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "baseDictionary",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "randomSeed",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.custom_dictionary(",
    "local": ""
  },
  {
    "origin": "nMarkers, markerSize[, randomSeed]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.custom_dictionary_from(",
    "local": ""
  },
  {
    "origin": "nMarkers, markerSize, baseDictionary[, randomSeed]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Generates a new customizable marker dictionary.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "nMarkers",
    "local": ""
  },
  {
    "origin": "number of markers in the dictionary",
    "local": ""
  },
  {
    "origin": "markerSize",
    "local": ""
  },
  {
    "origin": "number of bits per dimension of each markers",
    "local": ""
  },
  {
    "origin": "baseDictionary",
    "local": ""
  },
  {
    "origin": "Include the markers in this dictionary at the beginning (optional)",
    "local": ""
  },
  {
    "origin": "randomSeed",
    "local": ""
  },
  {
    "origin": "a user supplied seed for",
    "local": ""
  },
  {
    "origin": "This function creates a new dictionary composed by nMarkers markers and each markers composed by markerSize x markerSize bits. If baseDictionary is provided, its markers are directly included and the rest are generated based on them. If the size of baseDictionary is higher than nMarkers, only the first nMarkers in baseDictionary are taken and no new marker is added.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getBoardObjectAndImagePoints()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::getBoardObjectAndImagePoints",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "detectedCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "detectedIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "objPoints",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "imgPoints",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "objPoints, imgPoints",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.getBoardObjectAndImagePoints(",
    "local": ""
  },
  {
    "origin": "board, detectedCorners, detectedIds[, objPoints[, imgPoints]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Given a board configuration and a set of detected markers, returns the corresponding image points and object points to call solvePnP.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "Marker board layout.",
    "local": ""
  },
  {
    "origin": "detectedCorners",
    "local": ""
  },
  {
    "origin": "List of detected marker corners of the board.",
    "local": ""
  },
  {
    "origin": "detectedIds",
    "local": ""
  },
  {
    "origin": "List of identifiers for each marker.",
    "local": ""
  },
  {
    "origin": "objPoints",
    "local": ""
  },
  {
    "origin": "Vector of vectors of board marker points in the board coordinate space.",
    "local": ""
  },
  {
    "origin": "imgPoints",
    "local": ""
  },
  {
    "origin": "Vector of vectors of the projections of board marker corner points.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getPredefinedDictionary()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::aruco::getPredefinedDictionary",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "name",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.getPredefinedDictionary(",
    "local": ""
  },
  {
    "origin": "dict",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Returns one of the predefined dictionaries defined in PREDEFINED_DICTIONARY_NAME.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getPredefinedDictionary()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::aruco::getPredefinedDictionary",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dict",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.getPredefinedDictionary(",
    "local": ""
  },
  {
    "origin": "dict",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Returns one of the predefined dictionaries referenced by DICT_*.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "interpolateCornersCharuco()",
    "local": ""
  },
  {
    "origin": "int cv::aruco::interpolateCornersCharuco",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "markerCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "markerIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "minMarkers",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval, charucoCorners, charucoIds",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.interpolateCornersCharuco(",
    "local": ""
  },
  {
    "origin": "markerCorners, markerIds, image, board[, charucoCorners[, charucoIds[, cameraMatrix[, distCoeffs[, minMarkers]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Interpolate position of ChArUco board corners.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "markerCorners",
    "local": ""
  },
  {
    "origin": "vector of already detected markers corners. For each marker, its four corners are provided, (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.",
    "local": ""
  },
  {
    "origin": "markerIds",
    "local": ""
  },
  {
    "origin": "list of identifiers for each marker in corners",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input image necesary for corner refinement. Note that markers are not detected and should be sent in corners and ids parameters.",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "layout of ChArUco board.",
    "local": ""
  },
  {
    "origin": "charucoCorners",
    "local": ""
  },
  {
    "origin": "interpolated chessboard corners",
    "local": ""
  },
  {
    "origin": "charucoIds",
    "local": ""
  },
  {
    "origin": "interpolated chessboard corners identifiers",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "optional 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "optional vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "minMarkers",
    "local": ""
  },
  {
    "origin": "number of adjacent markers that must be detected to return a charuco corner",
    "local": ""
  },
  {
    "origin": "This function receives the detected markers and returns the 2D position of the chessboard corners from a ChArUco board using the detected Aruco markers. If camera parameters are provided, the process is based in an approximated pose estimation, else it is based on local homography. Only visible corners are returned. For each corner, its corresponding identifier is also returned in charucoIds. The function returns the number of interpolated corners.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "refineDetectedMarkers()",
    "local": ""
  },
  {
    "origin": "void cv::aruco::refineDetectedMarkers",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "detectedCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "detectedIds",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rejectedCorners",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "minRepDistance",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "errorCorrectionRate",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "checkAllOrders",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "recoveredIdxs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "parameters",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "detectedCorners, detectedIds, rejectedCorners, recoveredIdxs",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.refineDetectedMarkers(",
    "local": ""
  },
  {
    "origin": "image, board, detectedCorners, detectedIds, rejectedCorners[, cameraMatrix[, distCoeffs[, minRepDistance[, errorCorrectionRate[, checkAllOrders[, recoveredIdxs[, parameters]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Refind not detected markers based on the already detected and the board layout.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input image",
    "local": ""
  },
  {
    "origin": "board",
    "local": ""
  },
  {
    "origin": "layout of markers in the board.",
    "local": ""
  },
  {
    "origin": "detectedCorners",
    "local": ""
  },
  {
    "origin": "vector of already detected marker corners.",
    "local": ""
  },
  {
    "origin": "detectedIds",
    "local": ""
  },
  {
    "origin": "vector of already detected marker identifiers.",
    "local": ""
  },
  {
    "origin": "rejectedCorners",
    "local": ""
  },
  {
    "origin": "vector of rejected candidates during the marker detection process.",
    "local": ""
  },
  {
    "origin": "cameraMatrix",
    "local": ""
  },
  {
    "origin": "optional input 3x3 floating-point camera matrix \\(A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\)",
    "local": ""
  },
  {
    "origin": "distCoeffs",
    "local": ""
  },
  {
    "origin": "optional vector of distortion coefficients \\((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6],[s_1, s_2, s_3, s_4]])\\) of 4, 5, 8 or 12 elements",
    "local": ""
  },
  {
    "origin": "minRepDistance",
    "local": ""
  },
  {
    "origin": "minimum distance between the corners of the rejected candidate and the reprojected marker in order to consider it as a correspondence.",
    "local": ""
  },
  {
    "origin": "errorCorrectionRate",
    "local": ""
  },
  {
    "origin": "rate of allowed erroneous bits respect to the error correction capability of the used dictionary. -1 ignores the error correction step.",
    "local": ""
  },
  {
    "origin": "checkAllOrders",
    "local": ""
  },
  {
    "origin": "Consider the four posible corner orders in the rejectedCorners array. If it set to false, only the provided corner order is considered (default true).",
    "local": ""
  },
  {
    "origin": "recoveredIdxs",
    "local": ""
  },
  {
    "origin": "Optional array to returns the indexes of the recovered candidates in the original rejectedCorners array.",
    "local": ""
  },
  {
    "origin": "parameters",
    "local": ""
  },
  {
    "origin": "marker detection parameters",
    "local": ""
  },
  {
    "origin": "This function tries to find markers that were not detected in the basic detecMarkers function. First, based on the current detected marker and the board layout, the function interpolates the position of the missing markers. Then it tries to find correspondence between the reprojected markers and the rejected candidates based on the minRepDistance and errorCorrectionRate parameters. If camera parameters and distortion coefficients are provided, missing markers are reprojected using projectPoint function. If not, missing marker projections are interpolated using global homography, and all the marker corners in the board must have the same Z coordinate.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "testCharucoCornersCollinear()",
    "local": ""
  },
  {
    "origin": "bool cv::aruco::testCharucoCornersCollinear",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "_board",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "_charucoIds",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.aruco.testCharucoCornersCollinear(",
    "local": ""
  },
  {
    "origin": "_board, _charucoIds",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "test whether the ChArUco markers are collinear",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "_board",
    "local": ""
  },
  {
    "origin": "layout of ChArUco board.",
    "local": ""
  },
  {
    "origin": "_charucoIds",
    "local": ""
  },
  {
    "origin": "list of identifiers for each corner in charucoCorners per frame.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "bool value, 1 (true) if detected corners form a line, 0 (false) if they do not. solvePnP, calibration functions will fail if the corners are collinear (true).",
    "local": ""
  },
  {
    "origin": "The number of ids in charucoIDs should be &lt;= the number of chessboard corners in the board. This functions checks whether the charuco corners are on a straight line (returns true, if so), or not (false). Axis parallel, as well as diagonal and other straight lines detected. Degenerate cases: for number of charucoIDs &lt;= 2, the function returns true.",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:41 for OpenCV by",
    "local": ""
  }
]