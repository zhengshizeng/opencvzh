[
  {
    "origin": "OpenCV: opencv2/surface_matching/ppf_helpers.hpp File Reference",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "ppf_helpers.hpp File Reference",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "\"black box\" representation of the file storage associated with a file on disk.",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "(Mat pc, double scale)",
    "local": ""
  },
  {
    "origin": "(Mat pc, Vec2f &amp;xRange, Vec2f &amp;yRange, Vec2f &amp;zRange)",
    "local": ""
  },
  {
    "origin": "(const Mat &amp;PC, Mat &amp;PCNormals, const int NumNeighbors, const bool FlipViewpoint, const Vec3f &amp;viewpoint)",
    "local": ""
  },
  {
    "origin": "Compute the normals of an arbitrary point cloud computeNormalsPC3d uses a plane fitting approach to smoothly compute local normals. Normals are obtained through the eigenvector of the covariance matrix, corresponding to the smallest eigen value. If PCNormals is provided to be an Nx6 matrix, then no new allocation is made, instead the existing memory is overwritten.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(void *flannIndex)",
    "local": ""
  },
  {
    "origin": "(Matx44d &amp;Pose)",
    "local": ""
  },
  {
    "origin": "(Mat pc)",
    "local": ""
  },
  {
    "origin": "(const char *fileName, int withNormals=0)",
    "local": ""
  },
  {
    "origin": "Load a PLY file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(Mat pc, float scale, float *Cx, float *Cy, float *Cz, float *MinVal, float *MaxVal)",
    "local": ""
  },
  {
    "origin": "(void *flannIndex, Mat &amp;pc, Mat &amp;indices, Mat &amp;distances)",
    "local": ""
  },
  {
    "origin": "(void *flannIndex, Mat &amp;pc, Mat &amp;indices, Mat &amp;distances, const int numNeighbors)",
    "local": ""
  },
  {
    "origin": "(Mat pc, Vec2f &amp;xrange, Vec2f &amp;yrange, Vec2f &amp;zrange, float sample_step_relative, int weightByCenter=0)",
    "local": ""
  },
  {
    "origin": "(Mat PC, int sampleStep)",
    "local": ""
  },
  {
    "origin": "(Mat PC, int sampleStep, std::vector&lt; int &gt; &amp;indices)",
    "local": ""
  },
  {
    "origin": "(Mat pc, const Matx44d &amp;Pose)",
    "local": ""
  },
  {
    "origin": "(Mat pc, float scale, float Cx, float Cy, float Cz, float MinVal, float MaxVal)",
    "local": ""
  },
  {
    "origin": "(Mat PC, const char *fileName)",
    "local": ""
  },
  {
    "origin": "Write a point cloud to PLY file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(Mat PC, const char *fileName)",
    "local": ""
  },
  {
    "origin": "Used for debbuging pruposes, writes a point cloud to a PLY file with the tip of the normal vectors as visible red points.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Author",
    "local": ""
  },
  {
    "origin": "Tolga Birdal &lt;tbirdal AT gmail.com&gt;",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:33 for OpenCV by &#160;",
    "local": ""
  }
]