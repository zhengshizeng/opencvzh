[
  {
    "origin": "OpenCV: cv::optflow::DenseRLOFOpticalFlow Class Reference",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions",
    "local": ""
  },
  {
    "origin": "List of all members",
    "local": ""
  },
  {
    "origin": "cv::optflow::DenseRLOFOpticalFlow Class Reference",
    "local": ""
  },
  {
    "origin": "abstract",
    "local": ""
  },
  {
    "origin": "Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-to-dense interpolation scheme.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Inheritance diagram for cv::optflow::DenseRLOFOpticalFlow:",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() K value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() lambda value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() sigma value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "Threshold for the forward backward confidence check.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "Size of the grid to spawn the motion vectors.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "Interpolation used to compute the dense optical flow.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "Parameter to choose superpixel algorithm variant to use:",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "Parameter to tune the approximate size of the superpixel used for oversegmentation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "Configuration of the RLOF alogrithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() K value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() lambda value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() sigma value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "Threshold for the forward backward confidence check.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "Size of the grid to spawn the motion vectors.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "Interpolation used to compute the dense optical flow.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "Parameter to choose superpixel algorithm variant to use:",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "Parameter to tune the approximate size of the superpixel used for oversegmentation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "Configuration of the RLOF alogrithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "I0,",
    "local": ""
  },
  {
    "origin": "I1,",
    "local": ""
  },
  {
    "origin": "Calculates an optical flow.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "Releases all inner buffers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Clears the algorithm state.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "() const",
    "local": ""
  },
  {
    "origin": "Returns true if the",
    "local": ""
  },
  {
    "origin": "is empty (e.g. in the very beginning or after unsuccessful read.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "() const",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;fn)",
    "local": ""
  },
  {
    "origin": "Reads algorithm parameters from a file storage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename) const",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;fs) const",
    "local": ""
  },
  {
    "origin": "Stores algorithm parameters in a file storage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;fs, const",
    "local": ""
  },
  {
    "origin": "&amp;name=",
    "local": ""
  },
  {
    "origin": "()) const",
    "local": ""
  },
  {
    "origin": "simplified API for language bindings This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; rlofParam=",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;(), float forwardBackwardThreshold=1.f,",
    "local": ""
  },
  {
    "origin": "gridStep=",
    "local": ""
  },
  {
    "origin": "(6, 6),",
    "local": ""
  },
  {
    "origin": "interp_type=InterpolationType::INTERP_EPIC, int epicK=128, float epicSigma=0.05f, float epicLambda=999.0f, int ricSPSize=15, int ricSLICType=100, bool use_post_proc=true, float fgsLambda=500.0f, float fgsSigma=1.5f, bool use_variational_refinement=false)",
    "local": ""
  },
  {
    "origin": "Creates instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename, const",
    "local": ""
  },
  {
    "origin": "&amp;objname=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads algorithm from the file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;strModel, const",
    "local": ""
  },
  {
    "origin": "&amp;objname=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads algorithm from a String.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;fn)",
    "local": ""
  },
  {
    "origin": "Reads algorithm from the file node.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Additional Inherited Members",
    "local": ""
  },
  {
    "origin": "Protected Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;fs) const",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-to-dense interpolation scheme.",
    "local": ""
  },
  {
    "origin": "The RLOF is a fast local optical flow approach described in",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "similar to the pyramidal iterative Lucas-Kanade method as proposed by",
    "local": ""
  },
  {
    "origin": ". More details and experiments can be found in the following thesis",
    "local": ""
  },
  {
    "origin": ". The implementation is derived from",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "The sparse-to-dense interpolation scheme allows for fast computation of dense optical flow using RLOF (see",
    "local": ""
  },
  {
    "origin": "). For this scheme the following steps are applied:",
    "local": ""
  },
  {
    "origin": "motion vector seeded at a regular sampled grid are computed. The sparsity of this grid can be configured with setGridStep",
    "local": ""
  },
  {
    "origin": "(optinally) errornous motion vectors are filter based on the forward backward confidence. The threshold can be configured with setForwardBackward. The filter is only applied if the threshold &gt;0 but than the runtime is doubled due to the estimation of the backward flow.",
    "local": ""
  },
  {
    "origin": "Vector field interpolation is applied to the motion vector set to obtain a dense vector field.",
    "local": ""
  },
  {
    "origin": "For the RLOF configuration see",
    "local": ""
  },
  {
    "origin": "for further details. Parameters have been described in",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "If the grid size is set to (1,1) and the forward backward threshold &lt;= 0 than pixelwise dense optical flow field is computed by RLOF without using interpolation.",
    "local": ""
  },
  {
    "origin": "Note that in output, if no correspondences are found between",
    "local": ""
  },
  {
    "origin": "I0",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "I1",
    "local": ""
  },
  {
    "origin": ", the",
    "local": ""
  },
  {
    "origin": "flow",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Member Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "create()",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::optflow::DenseRLOFOpticalFlow::create",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "rlofParam",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "forwardBackwardThreshold",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "gridStep",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "interp_type",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "epicK",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "epicSigma",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "epicLambda",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ricSPSize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ricSLICType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "use_post_proc",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "fgsLambda",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "fgsSigma",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "use_variational_refinement",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow.DenseRLOFOpticalFlow_create(",
    "local": ""
  },
  {
    "origin": "[, rlofParam[, forwardBackwardThreshold[, gridStep[, interp_type[, epicK[, epicSigma[, epicLambda[, ricSPSize[, ricSLICType[, use_post_proc[, fgsLambda[, fgsSigma[, use_variational_refinement]]]]]]]]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates instance of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "rlofParam",
    "local": ""
  },
  {
    "origin": "see",
    "local": ""
  },
  {
    "origin": "forwardBackwardThreshold",
    "local": ""
  },
  {
    "origin": "see setForwardBackward",
    "local": ""
  },
  {
    "origin": "gridStep",
    "local": ""
  },
  {
    "origin": "see setGridStep",
    "local": ""
  },
  {
    "origin": "interp_type",
    "local": ""
  },
  {
    "origin": "see setInterpolation",
    "local": ""
  },
  {
    "origin": "epicK",
    "local": ""
  },
  {
    "origin": "see setEPICK",
    "local": ""
  },
  {
    "origin": "epicSigma",
    "local": ""
  },
  {
    "origin": "see setEPICSigma",
    "local": ""
  },
  {
    "origin": "epicLambda",
    "local": ""
  },
  {
    "origin": "see setEPICLambda",
    "local": ""
  },
  {
    "origin": "ricSPSize",
    "local": ""
  },
  {
    "origin": "see setRICSPSize",
    "local": ""
  },
  {
    "origin": "ricSLICType",
    "local": ""
  },
  {
    "origin": "see setRICSLICType",
    "local": ""
  },
  {
    "origin": "use_post_proc",
    "local": ""
  },
  {
    "origin": "see setUsePostProc",
    "local": ""
  },
  {
    "origin": "fgsLambda",
    "local": ""
  },
  {
    "origin": "see setFgsLambda",
    "local": ""
  },
  {
    "origin": "fgsSigma",
    "local": ""
  },
  {
    "origin": "see setFgsSigma",
    "local": ""
  },
  {
    "origin": "use_variational_refinement",
    "local": ""
  },
  {
    "origin": "see setUseVariationalRefinement",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getEPICK()",
    "local": ""
  },
  {
    "origin": "virtual int cv::optflow::DenseRLOFOpticalFlow::getEPICK",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getEPICK(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() K value.",
    "local": ""
  },
  {
    "origin": "K is a number of nearest-neighbor matches considered, when fitting a locally affine model. Usually it should be around 128. However, lower values would make the interpolation noticeably faster.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getEPICLambda()",
    "local": ""
  },
  {
    "origin": "virtual float cv::optflow::DenseRLOFOpticalFlow::getEPICLambda",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getEPICLambda(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() lambda value.",
    "local": ""
  },
  {
    "origin": "Lambda is a parameter defining the weight of the edge-aware term in geodesic distance, should be in the range of 0 to 1000.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getEPICSigma()",
    "local": ""
  },
  {
    "origin": "virtual float cv::optflow::DenseRLOFOpticalFlow::getEPICSigma",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getEPICSigma(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() sigma value.",
    "local": ""
  },
  {
    "origin": "Sigma is a parameter defining how fast the weights decrease in the locally-weighted affine fitting. Higher values can help preserve fine details, lower values can help to get rid of noise in the output flow.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getFgsLambda()",
    "local": ""
  },
  {
    "origin": "virtual float cv::optflow::DenseRLOFOpticalFlow::getFgsLambda",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getFgsLambda(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "Sets the respective",
    "local": ""
  },
  {
    "origin": "parameter.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getFgsSigma()",
    "local": ""
  },
  {
    "origin": "virtual float cv::optflow::DenseRLOFOpticalFlow::getFgsSigma",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getFgsSigma(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "Sets the respective",
    "local": ""
  },
  {
    "origin": "parameter.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getForwardBackward()",
    "local": ""
  },
  {
    "origin": "virtual float cv::optflow::DenseRLOFOpticalFlow::getForwardBackward",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getForwardBackward(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Threshold for the forward backward confidence check.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getGridStep()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "cv::optflow::DenseRLOFOpticalFlow::getGridStep",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getGridStep(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Size of the grid to spawn the motion vectors.",
    "local": ""
  },
  {
    "origin": "For each grid point a motion vector is computed. Some motion vectors will be removed due to the forwatd backward threshold (if set &gt;0). The rest will be the base of the vector field interpolation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getInterpolation()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "cv::optflow::DenseRLOFOpticalFlow::getInterpolation",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getInterpolation(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Interpolation used to compute the dense optical flow.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRICSLICType()",
    "local": ""
  },
  {
    "origin": "virtual int cv::optflow::DenseRLOFOpticalFlow::getRICSLICType",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getRICSLICType(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Parameter to choose superpixel algorithm variant to use:",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRICSPSize()",
    "local": ""
  },
  {
    "origin": "virtual int cv::optflow::DenseRLOFOpticalFlow::getRICSPSize",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getRICSPSize(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Parameter to tune the approximate size of the superpixel used for oversegmentation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRLOFOpticalFlowParameter()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::optflow::DenseRLOFOpticalFlow::getRLOFOpticalFlowParameter",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getRLOFOpticalFlowParameter(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Configuration of the RLOF alogrithm.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getUsePostProc()",
    "local": ""
  },
  {
    "origin": "virtual bool cv::optflow::DenseRLOFOpticalFlow::getUsePostProc",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getUsePostProc(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getUseVariationalRefinement()",
    "local": ""
  },
  {
    "origin": "virtual bool cv::optflow::DenseRLOFOpticalFlow::getUseVariationalRefinement",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.getUseVariationalRefinement(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setEPICK()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setEPICK",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setEPICK(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() K value.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setEPICLambda()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setEPICLambda",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setEPICLambda(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() lambda value.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setEPICSigma()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setEPICSigma",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setEPICSigma(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator() sigma value.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setFgsLambda()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setFgsLambda",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setFgsLambda(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setFgsSigma()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setFgsSigma",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setFgsSigma(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "see ximgproc::EdgeAwareInterpolator().",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setForwardBackward()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setForwardBackward",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setForwardBackward(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Threshold for the forward backward confidence check.",
    "local": ""
  },
  {
    "origin": "For each grid point \\( \\mathbf{x} \\) a motion vector \\( d_{I0,I1}(\\mathbf{x}) \\) is computed. If the forward backward error",
    "local": ""
  },
  {
    "origin": "\\[ EP_{FB} = || d_{I0,I1} + d_{I1,I0} || \\]",
    "local": ""
  },
  {
    "origin": "is larger than threshold given by this function then the motion vector will not be used by the following vector field interpolation. \\( d_{I1,I0} \\) denotes the backward flow. Note, the forward backward test will only be applied if the threshold &gt; 0. This may results into a doubled runtime for the motion estimation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setGridStep()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setGridStep",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setGridStep(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Size of the grid to spawn the motion vectors.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setInterpolation()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setInterpolation",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setInterpolation(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Interpolation used to compute the dense optical flow.",
    "local": ""
  },
  {
    "origin": "Two interpolation algorithms are supported",
    "local": ""
  },
  {
    "origin": "INTERP_GEO",
    "local": ""
  },
  {
    "origin": "applies the fast geodesic interpolation, see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "INTERP_EPIC_RESIDUAL",
    "local": ""
  },
  {
    "origin": "applies the edge-preserving interpolation, see",
    "local": ""
  },
  {
    "origin": ",Geistert2016.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setRICSLICType()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setRICSLICType",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setRICSLICType(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Parameter to choose superpixel algorithm variant to use:",
    "local": ""
  },
  {
    "origin": "SLIC segments image using a desired region_size (value: 100)",
    "local": ""
  },
  {
    "origin": "SLICO will optimize using adaptive compactness factor (value: 101)",
    "local": ""
  },
  {
    "origin": "MSLIC will optimize using manifold methods resulting in more content-sensitive superpixels (value: 102).",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setRICSPSize()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setRICSPSize",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setRICSPSize(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Parameter to tune the approximate size of the superpixel used for oversegmentation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setRLOFOpticalFlowParameter()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setRLOFOpticalFlowParameter",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setRLOFOpticalFlowParameter(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Configuration of the RLOF alogrithm.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setUsePostProc()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setUsePostProc",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setUsePostProc(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setUseVariationalRefinement()",
    "local": ""
  },
  {
    "origin": "virtual void cv::optflow::DenseRLOFOpticalFlow::setUseVariationalRefinement",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.optflow_DenseRLOFOpticalFlow.setUseVariationalRefinement(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "enables",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "The documentation for this class was generated from the following file:",
    "local": ""
  },
  {
    "origin": "opencv2/optflow/",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:48 for OpenCV by",
    "local": ""
  }
]