[
  {
    "origin": "OpenCV: cv::SVD Class Reference",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Public Types",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions",
    "local": ""
  },
  {
    "origin": "Public Attributes",
    "local": ""
  },
  {
    "origin": "List of all members",
    "local": ""
  },
  {
    "origin": "cv::SVD Class Reference",
    "local": ""
  },
  {
    "origin": "&raquo;",
    "local": ""
  },
  {
    "origin": "Singular Value Decomposition.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Types",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "the default constructor",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src, int flags=0)",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "rhs,",
    "local": ""
  },
  {
    "origin": "dst) const",
    "local": ""
  },
  {
    "origin": "performs a singular value back substitution.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src, int flags=0)",
    "local": ""
  },
  {
    "origin": "the operator that performs",
    "local": ""
  },
  {
    "origin": ". The previously allocated u, w and vt are released.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rhs,",
    "local": ""
  },
  {
    "origin": "dst)",
    "local": ""
  },
  {
    "origin": "performs back substitution",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp , int m, int n, int nm, int nb&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, nm, 1 &gt; &amp;",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, m, nm &gt; &amp;",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, n, nm &gt; &amp;",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, m, nb &gt; &amp;rhs,",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, n, nb &gt; &amp;dst)",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", int flags=0)",
    "local": ""
  },
  {
    "origin": "decomposes matrix and stores the results to user-provided matrices",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": ", int flags=0)",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp , int m, int n, int nm&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, m, n &gt; &amp;a,",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, nm, 1 &gt; &amp;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, m, nm &gt; &amp;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, n, nm &gt; &amp;",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp , int m, int n, int nm&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, m, n &gt; &amp;a,",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, nm, 1 &gt; &amp;",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst)",
    "local": ""
  },
  {
    "origin": "solves an under-determined singular linear system",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Attributes",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Singular Value Decomposition.",
    "local": ""
  },
  {
    "origin": "Class for computing Singular Value Decomposition of a floating-point matrix. The Singular Value Decomposition is used to solve least-square problems, under-determined linear systems, invert matrices, compute condition numbers, and so on.",
    "local": ""
  },
  {
    "origin": "If you want to compute a condition number of a matrix or an absolute value of its determinant, you do not need",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ". You can pass flags=",
    "local": ""
  },
  {
    "origin": "|... . Another flag",
    "local": ""
  },
  {
    "origin": "indicates that full-size u and vt must be computed, which is not necessary most of the time.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Member Enumeration Documentation",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "Flags",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "allow the algorithm to modify the decomposed matrix; it can save space and speed up processing. currently ignored.",
    "local": ""
  },
  {
    "origin": "indicates that only a vector of singular values",
    "local": ""
  },
  {
    "origin": "is to be processed, while u and vt will be set to empty matrices",
    "local": ""
  },
  {
    "origin": "when the matrix is not square, by default the algorithm produces u and vt matrices of sufficiently large size for the further A reconstruction; if, however, FULL_UV flag is specified, u and vt will be full-size square orthogonal matrices.",
    "local": ""
  },
  {
    "origin": "Constructor &amp; Destructor Documentation",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "SVD()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::SVD::SVD",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "the default constructor",
    "local": ""
  },
  {
    "origin": "initializes an empty",
    "local": ""
  },
  {
    "origin": "structure",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "SVD()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::SVD::SVD",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. initializes an empty",
    "local": ""
  },
  {
    "origin": "structure and then calls SVD::operator()",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "decomposed matrix. The depth has to be CV_32F or CV_64F.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "operation flags (",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Member Function Documentation",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "backSubst()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::backSubst",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "u",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "vt",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "rhs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "performs back substitution",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "backSubst()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "void cv::SVD::backSubst",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "rhs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "performs a singular value back substitution.",
    "local": ""
  },
  {
    "origin": "The method calculates a back substitution for the specified right-hand side:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{x} = \\texttt{vt} ^T \\cdot diag( \\texttt{w} )^{-1} \\cdot \\texttt{u} ^T \\cdot \\texttt{rhs} \\sim \\texttt{A} ^{-1} \\cdot \\texttt{rhs}\\]",
    "local": ""
  },
  {
    "origin": "Using this technique you can either get a very accurate solution of the convenient linear system, or the best (in the least-squares terms) pseudo-solution of an overdetermined linear system.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "rhs",
    "local": ""
  },
  {
    "origin": "right-hand side of a linear system (u*w*v')*dst = rhs to be solved, where A has been previously decomposed.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "found solution of the system.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Explicit",
    "local": ""
  },
  {
    "origin": "with the further back substitution only makes sense if you need to solve many linear systems with the same left-hand side (for example, src ). If all you need is to solve a single system (possibly with multiple rhs immediately available), simply call solve add pass",
    "local": ""
  },
  {
    "origin": "there. It does absolutely the same thing.",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "backSubst()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp , int m, int n, int nm, int nb&gt;",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::backSubst",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, nm, 1 &gt; &amp;&#160;",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "u",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "vt",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "rhs",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "document",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "compute()",
    "local": ""
  },
  {
    "origin": "[1/4]",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::compute",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "u",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "vt",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "decomposes matrix and stores the results to user-provided matrices",
    "local": ""
  },
  {
    "origin": "The methods/functions perform",
    "local": ""
  },
  {
    "origin": "of matrix. Unlike",
    "local": ""
  },
  {
    "origin": "constructor and SVD::operator(), they store the results to the user-provided matrices:",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "decomposed matrix. The depth has to be CV_32F or CV_64F.",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": "calculated singular values",
    "local": ""
  },
  {
    "origin": "u",
    "local": ""
  },
  {
    "origin": "calculated left singular vectors",
    "local": ""
  },
  {
    "origin": "vt",
    "local": ""
  },
  {
    "origin": "transposed matrix of right singular vectors",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "operation flags - see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "compute()",
    "local": ""
  },
  {
    "origin": "[2/4]",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::compute",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. computes singular values of a matrix",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "decomposed matrix. The depth has to be CV_32F or CV_64F.",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": "calculated singular values",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "operation flags - see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "compute()",
    "local": ""
  },
  {
    "origin": "[3/4]",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp , int m, int n, int nm&gt;",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::compute",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "a",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, nm, 1 &gt; &amp;&#160;",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "u",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "vt",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "document",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "compute()",
    "local": ""
  },
  {
    "origin": "[4/4]",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp , int m, int n, int nm&gt;",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::compute",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "a",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&lt; _Tp, nm, 1 &gt; &amp;&#160;",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "document",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "operator()()",
    "local": ""
  },
  {
    "origin": "&amp; cv::SVD::operator()",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "the operator that performs",
    "local": ""
  },
  {
    "origin": ". The previously allocated u, w and vt are released.",
    "local": ""
  },
  {
    "origin": "The operator performs the singular value decomposition of the supplied matrix. The u,",
    "local": ""
  },
  {
    "origin": ", and the vector of singular values w are stored in the structure. The same",
    "local": ""
  },
  {
    "origin": "structure can be reused many times with different matrices. Each time, if needed, the previous u,",
    "local": ""
  },
  {
    "origin": ", and w are reclaimed and the new matrices are created, which is all handled by",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "decomposed matrix. The depth has to be CV_32F or CV_64F.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "operation flags (",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "solveZ()",
    "local": ""
  },
  {
    "origin": "static void cv::SVD::solveZ",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "solves an under-determined singular linear system",
    "local": ""
  },
  {
    "origin": "The method finds a unit-length solution x of a singular linear system A*x = 0. Depending on the rank of A, there can be no solutions, a single solution or an infinite number of solutions. In general, the algorithm solves the following problem:",
    "local": ""
  },
  {
    "origin": "\\[dst = \\arg \\min _{x: \\| x \\| =1} \\| src \\cdot x \\|\\]",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "left-hand-side matrix.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "found solution.",
    "local": ""
  },
  {
    "origin": "Member Data Documentation",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "u",
    "local": ""
  },
  {
    "origin": "cv::SVD::u",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "vt",
    "local": ""
  },
  {
    "origin": "cv::SVD::vt",
    "local": ""
  },
  {
    "origin": "&#9670;&nbsp;",
    "local": ""
  },
  {
    "origin": "w",
    "local": ""
  },
  {
    "origin": "cv::SVD::w",
    "local": ""
  },
  {
    "origin": "The documentation for this class was generated from the following file:",
    "local": ""
  },
  {
    "origin": "opencv2/",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:43 for OpenCV by &#160;",
    "local": ""
  }
]