[
  {
    "origin": "OpenCV: Custom deep learning layers support",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Custom deep learning layers support",
    "local": ""
  },
  {
    "origin": "Prev Tutorial:",
    "local": ""
  },
  {
    "origin": "Next Tutorial:",
    "local": ""
  },
  {
    "origin": "Original author",
    "local": ""
  },
  {
    "origin": "Dmitry Kurtaev",
    "local": ""
  },
  {
    "origin": "Compatibility",
    "local": ""
  },
  {
    "origin": "Introduction",
    "local": ""
  },
  {
    "origin": "Deep learning is a fast growing area. The new approaches to build neural networks usually introduce new types of layers. They could be modifications of existing ones or implement outstanding researching ideas.",
    "local": ""
  },
  {
    "origin": "OpenCV gives an opportunity to import and run networks from different deep learning frameworks. There are a number of the most popular layers. However you can face a problem that your network cannot be imported using OpenCV because of unimplemented layers.",
    "local": ""
  },
  {
    "origin": "The first solution is to create a feature request at",
    "local": ""
  },
  {
    "origin": "https://github.com/opencv/opencv/issues",
    "local": ""
  },
  {
    "origin": "mentioning details such a source of model and type of new layer. A new layer could be implemented if OpenCV community shares this need.",
    "local": ""
  },
  {
    "origin": "The second way is to define a",
    "local": ""
  },
  {
    "origin": "custom layer",
    "local": ""
  },
  {
    "origin": "so OpenCV's deep learning engine will know how to use it. This tutorial is dedicated to show you a process of deep learning models import customization.",
    "local": ""
  },
  {
    "origin": "Define a custom layer in C++",
    "local": ""
  },
  {
    "origin": "Deep learning layer is a building block of network's pipeline. It has connections to",
    "local": ""
  },
  {
    "origin": "input blobs",
    "local": ""
  },
  {
    "origin": "and produces results to",
    "local": ""
  },
  {
    "origin": "output blobs",
    "local": ""
  },
  {
    "origin": ". There are trained",
    "local": ""
  },
  {
    "origin": "weights",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "hyper-parameters",
    "local": ""
  },
  {
    "origin": ". Layers' names, types, weights and hyper-parameters are stored in files are generated by native frameworks during training. If OpenCV mets unknown layer type it throws an exception trying to read a model:",
    "local": ""
  },
  {
    "origin": "To import the model correctly you have to derive a class from",
    "local": ""
  },
  {
    "origin": "with the following methods:",
    "local": ""
  },
  {
    "origin": "And register it before the import:",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "is a type of unimplemented layer from the thrown exception.",
    "local": ""
  },
  {
    "origin": "Let's see what all the methods do:",
    "local": ""
  },
  {
    "origin": "Constructor",
    "local": ""
  },
  {
    "origin": "Retrieves hyper-parameters from",
    "local": ""
  },
  {
    "origin": ". If your layer has trainable weights they will be already stored in the Layer's member",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "A static method",
    "local": ""
  },
  {
    "origin": "This method should create an instance of you layer and return",
    "local": ""
  },
  {
    "origin": "with it.",
    "local": ""
  },
  {
    "origin": "Output blobs' shape computation",
    "local": ""
  },
  {
    "origin": "Returns layer's output shapes depends on input shapes. You may request an extra memory using",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Run a layer",
    "local": ""
  },
  {
    "origin": "Implement a layer's logic here. Compute outputs for given inputs.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "OpenCV manages memory allocated for layers. In the most cases the same memory can be reused between layers. So your",
    "local": ""
  },
  {
    "origin": "implementation should not rely that the second invocation of",
    "local": ""
  },
  {
    "origin": "will has the same data at",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Optional",
    "local": ""
  },
  {
    "origin": "method",
    "local": ""
  },
  {
    "origin": "The chain of methods are the following: OpenCV deep learning engine calls",
    "local": ""
  },
  {
    "origin": "method once then it calls",
    "local": ""
  },
  {
    "origin": "for an every created layer then you can make some preparations depends on known input dimensions at",
    "local": ""
  },
  {
    "origin": ". After network was initialized only",
    "local": ""
  },
  {
    "origin": "method is called for an every network's input.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Varying input blobs' sizes such height or width or batch size you make OpenCV reallocate all the internal memory. That leads efficiency gaps. Try to initialize and deploy models using a fixed batch size and image's dimensions.",
    "local": ""
  },
  {
    "origin": "Example: custom layer from Caffe",
    "local": ""
  },
  {
    "origin": "Let's create a custom layer",
    "local": ""
  },
  {
    "origin": "from",
    "local": ""
  },
  {
    "origin": "https://github.com/cdmh/deeplab-public",
    "local": ""
  },
  {
    "origin": ". It's just a simple resize that takes an input blob of size",
    "local": ""
  },
  {
    "origin": "and returns an output blob of size",
    "local": ""
  },
  {
    "origin": "where",
    "local": ""
  },
  {
    "origin": "is a batch size,",
    "local": ""
  },
  {
    "origin": "is a number of channels,",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "are input and output",
    "local": ""
  },
  {
    "origin": "correspondingly. This layer has no trainable weights but it has hyper-parameters to specify an output size.",
    "local": ""
  },
  {
    "origin": "In example,",
    "local": ""
  },
  {
    "origin": "This way our implementation can look like:",
    "local": ""
  },
  {
    "origin": "Next we need to register a new layer type and try to import the model.",
    "local": ""
  },
  {
    "origin": "Example: custom layer from TensorFlow",
    "local": ""
  },
  {
    "origin": "This is an example of how to import a network with",
    "local": ""
  },
  {
    "origin": "tf.image.resize_bilinear",
    "local": ""
  },
  {
    "origin": "operation. This is also a resize but with an implementation different from OpenCV's or",
    "local": ""
  },
  {
    "origin": "above.",
    "local": ""
  },
  {
    "origin": "Let's create a single layer network:",
    "local": ""
  },
  {
    "origin": "OpenCV sees that TensorFlow's graph in the following way:",
    "local": ""
  },
  {
    "origin": "Custom layers import from TensorFlow is designed to put all layer's",
    "local": ""
  },
  {
    "origin": "into",
    "local": ""
  },
  {
    "origin": "but input",
    "local": ""
  },
  {
    "origin": "blobs into",
    "local": ""
  },
  {
    "origin": ". In our case resize's output shape will be stored in layer's",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Next we register a layer and try to import the model.",
    "local": ""
  },
  {
    "origin": "Define a custom layer in Python",
    "local": ""
  },
  {
    "origin": "The following example shows how to customize OpenCV's layers in Python.",
    "local": ""
  },
  {
    "origin": "Let's consider",
    "local": ""
  },
  {
    "origin": "Holistically-Nested Edge Detection",
    "local": ""
  },
  {
    "origin": "deep learning model. That was trained with one and only difference comparing to a current version of",
    "local": ""
  },
  {
    "origin": "Caffe framework",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "layers that receive two input blobs and crop the first one to match spatial dimensions of the second one used to crop from the center. Nowadays Caffe's layer does it from the top-left corner. So using the latest version of Caffe or OpenCV you'll get shifted results with filled borders.",
    "local": ""
  },
  {
    "origin": "Next we're going to replace OpenCV's",
    "local": ""
  },
  {
    "origin": "layer that makes top-left cropping by a centric one.",
    "local": ""
  },
  {
    "origin": "Create a class with",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "methods",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Both methods should return lists.",
    "local": ""
  },
  {
    "origin": "Register a new layer.",
    "local": ""
  },
  {
    "origin": "That's it! We've replaced an implemented OpenCV's layer to a custom one. You may find a full script in the",
    "local": ""
  },
  {
    "origin": "source code",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:34 for OpenCV by &#160;",
    "local": ""
  }
]