<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=9">
<meta name="generator" content="Doxygen 1.8.13">
<title>OpenCV:Mat-基本图像容器</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.5.2</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/df8/tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="../../de/d7a/tutorial_table_of_content_core.html">The Core Functionality (core module)</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Mat-基本图像容器</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>下一个教程:</b> <a class="el" href="../../db/da5/tutorial_how_to_scan_images.html">How to scan images, lookup tables and time measurement with OpenCV</a></p>
<table class="doxtable">
<tr>
<th align="right"></th><th align="left"></th></tr>
<tr>
<td align="right">原作者</td><td align="left">Bernát Gábor</td></tr>
<tr>
<td align="right">兼容性</td><td align="left">OpenCV &gt;= 3.0</td></tr>
</table>
<h2>目标</h2>
<p>我们有多种方法从现实世界中获取数字图像:数码相机、扫描仪、计算机断层扫描和磁共振成像等等.在任何情况下,我们(人类)看到的都是图像.然而,当把它转换到我们的数字设备时,我们记录的是图像中每个点的数值.</p>
<div class="image">
<img src="../../MatBasicImageForComputer.jpg" alt="MatBasicImageForComputer.jpg">
</div>
<p>例如,在上图中,你可以看到汽车的后视镜不过是一个包含所有像素点强度值的矩阵.我们获取和存储像素值的方式可能会根据我们的需要而有所不同,但最终,计算机世界中的所有图像都可能被简化为数字矩阵和描述矩阵本身的其他信息.<em>OpenCV</em>是一个计算机视觉库,其主要任务是处理和操纵这些信息.因此,您首先需要熟悉OpenCV如何存储和处理图像.</p>
<h2>Mat</h2>
<p>OpenCV从2001年就开始出现了,那时的图书馆是围绕一个<em>C</em>接口并将图像存储在内存中,他们使用了一个名为<em>IplImage</em>. 这是一个你会看到在大多数旧的教程和教材.这样做的问题是,它将C语言的所有缺点都摆到了桌面上.最大的问题是手动内存管理.它建立在用户负责内存分配和释放的假设之上.虽然这对于较小的程序来说不是问题,但一旦代码库增长,处理所有这些问题将比专注于解决开发目标更困难.</p>
<p>幸运的是C++出现并介绍了通过自动内存管理(或多或少)为用户提供更容易的类的概念.好消息是C++完全兼容C,所以不需要从更改中产生兼容性问题.因此,OpenCV 2引入了一个新的C++接口,它提供了一种新的做事方式,这意味着你不需要费力地进行内存管理,使代码简洁(少写,多做).C++接口的主要缺点是,目前许多嵌入式开发系统只支持C.因此,除非您针对嵌入式平台,否则使用<em>old</em>方法(除非你是一个受虐狂程序员,你是自找麻烦).</p>
<p>你要知道的第一件事<em>Mat</em>您不再需要手动分配它的内存,并且在不需要时立即释放它.尽管这样做仍然是可能的,但大多数OpenCV函数将自动分配其输出数据.作为一个不错的奖励,如果你把一个已经存在的<em>Mat</em>对象,它已经为矩阵分配了所需的空间,这将被重用.换句话说,我们在任何时候都只使用执行任务所需的内存.</p>
<p><em>Mat</em>基本上是一个包含两个数据部分的类:矩阵头(包含诸如矩阵大小、用于存储的方法、矩阵存储在哪个地址等信息)和指向包含像素值的矩阵的指针(根据选择的存储方法采用任何维数).矩阵头的大小是恒定的,但是矩阵本身的大小可能因图像而异,通常要大几个数量级.</p>
<p>OpenCV是一个图像处理库.它包含大量的图像处理函数集合.为了解决计算难题,大多数情况下,您将最终使用库的多个函数.因此,将图像传递给函数是一种常见的做法.我们不应该忘记,我们正在谈论的图像处理算法,往往是相当繁重的计算.我们最不想做的事情是进一步降低您的程序的速度,使不必要的副本<em>大的</em>图像.</p>
<p>为了解决这个问题,OpenCV使用了一个引用计数系统.我们的想法是<em>Mat</em>对象有自己的头,但是两个对象之间可以共享一个矩阵<em>Mat</em>对象的矩阵指针指向同一地址.此外,复制运算符<b>将只复制标题</b>指向大矩阵的指针,而不是数据本身.</p>
<div class="fragment"><div class="line">Mat A, C;                          <span class="comment">// creates just the header parts</span></div><div class="line">A = <a class="code" href="../../d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56">imread</a>(argv[1], <a class="code" href="../../d8/d6a/group__imgcodecs__flags.html#gga61d9b0126a3e57d9277ac48327799c80af660544735200cbe942eea09232eb822">IMREAD_COLOR</a>); <span class="comment">// here we&#39;ll know the method used (allocate matrix)</span></div><div class="line"></div><div class="line">Mat B(A);                                 <span class="comment">// Use the copy constructor</span></div><div class="line"></div><div class="line">C = A;                                    <span class="comment">// Assignment operator</span></div></div><!-- fragment --><p>最后,上述所有对象都指向同一个数据矩阵,使用其中任何一个对象进行修改都会影响其他所有对象.实际上,不同的对象只是为相同的底层数据提供了不同的访问方法.尽管如此,它们的标题部分是不同的.真正有趣的是,您可以创建只引用完整数据的一部分的头.例如,创建感兴趣的区域(<em>ROI</em>)在图像中,您只需创建一个具有新边界的新标题:</p><div class="fragment"><div class="line">Mat D (A, <a class="code" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a>(10, 10, 100, 100) ); <span class="comment">// using a rectangle</span></div><div class="line">Mat E = A(Range::all(), Range(1,3)); <span class="comment">// using row and column boundaries</span></div></div><!-- fragment --><p>现在你可以问-- 如果矩阵本身可能属于多个<em>Mat</em>当不再需要时负责清理的对象.简单的回答是:使用它的最后一个对象.这是通过使用引用计数机制来处理的.每当有人复制<em>Mat</em>对象,则为矩阵增加一个计数器.每当清洁收割台时,此计数器就会减小.当计数器为零时,矩阵被释放.有时您还需要复制矩阵本身,因此OpenCV提供了<a class="el" href="../../d3/d63/classcv_1_1Mat.html#adff2ea98da45eae0833e73582dd4a660">cv::Mat::clone()</a><a class="el" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">cv::Mat::copyTo()</a>功能.</p><div class="fragment"><div class="line">Mat F = A.clone();</div><div class="line">Mat G;</div><div class="line">A.copyTo(G);</div></div><!-- fragment --><p>正在修改<em>F</em><em>G</em><em>A</em>的标题.你需要记住的是:</p>
<ul>
<li>OpenCV函数的输出图像分配是自动的(除非另有规定).</li>
<li></li>
<li></li>
<li>图像的基础矩阵可以使用<a class="el" href="../../d3/d63/classcv_1_1Mat.html#adff2ea98da45eae0833e73582dd4a660">cv::Mat::clone()</a>和<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">cv::Mat::copyTo()</a>功能.</li>
</ul>
<h2>储存方法</h2>
<p></p>
<p><em>丰富多彩的</em>我们有很多方法可供选择.它们中的每一个都将其分解为三到四个基本组件,我们可以使用这些组件的组合来创建其他组件.最流行的是RGB,主要是因为这也是我们的眼睛如何建立颜色.它的基色是红、绿、蓝.为了对颜色的透明度进行编码,有时会添加第四个元素:alpha(a).</p>
<p></p>
<ul>
<li>RGB是最常见的,因为我们的眼睛使用类似的东西,但是请记住,OpenCV标准显示系统使用BGR颜色空间组成颜色(红色和蓝色通道交换位置).</li>
<li>HSV和HLS将颜色分解为色调、饱和度和值/亮度分量,这是一种更自然的颜色描述方法.例如,您可能会忽略最后一个组件,使算法对输入图像的光照条件不太敏感.</li>
<li>YCrCb是流行的JPEG图像格式.</li>
<li>CIE L*a*b*是一个感知一致的颜色空间,如果你需要测量颜色,它会很方便<em>距离</em>把一种颜色变成另一种颜色.</li>
</ul>
<p><em>烧焦</em>,表示一个字节或8位.它可以是无符号的(因此可以存储0到255之间的值)或有符号的(值从-127到+127).尽管在三个组件的情况下,这已经提供了1600万种可能的颜色来表示(如在RGB的情况下),但是我们可以通过为每个组件使用浮点(4字节=32位)或双(8字节=64位)数据类型来获得更精细的控制.然而,请记住,增大组件的大小也会增大内存中整个图片的大小.</p>
<h2>显式创建材质对象</h2>
<p>在<a class="el" href="../../db/d64/tutorial_load_save_image.html">Load, Modify, and Save an Image</a>教程您已经学习了如何使用<a class="el" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">cv::imwrite()</a><em>Mat</em></p>
<p>尽管<em>Mat</em>作为一个图像容器工作得非常好,它也是一个通用的矩阵类.因此,可以创建和操作多维矩阵.可以通过多种方式创建材质对象:</p>
<ul>
<li><p class="startli"><a class="el" href="../../d3/d63/classcv_1_1Mat.html#a2c4229732da267f1fe385458af3896d8">cv::Mat::Mat</a>建造师</p>
<div class="fragment"><div class="line">    Mat M(2,2, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>, <a class="code" href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">Scalar</a>(0,0,255));</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;M = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut1.png" alt="MatBasicContainerOut1.png">
</div>
<p class="startli">对于二维和多通道图像,我们首先定义它们的大小:按行和列计数.</p>
<p class="startli"></p><div class="fragment"><div class="line">CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</div></div><!-- fragment --><p>例如,<em>CV8UC3</em>意味着我们使用8位长的无符号字符类型,每个像素有三个这样的字符组成三个通道.最多可为四个通道预定义类型.这个<a class="el" href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">cv::Scalar</a>是四元素短向量.指定它,可以用自定义值初始化所有矩阵点.如果您需要更多,您可以使用上面的宏创建类型,设置括号中的通道号,如下所示.</p>
</li>
<li><p class="startli">使用C/C++数组通过构造函数初始化</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> sz[3] = {2,2,2};</div><div class="line">    Mat L(3,sz, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga78c5506f62d99edd7e83aba259250394">CV_8UC</a>(1), Scalar::all(0));</div></div><!-- fragment --><p>上面的示例演示如何创建具有两个以上维度的矩阵.指定其维度,然后传递一个包含每个维度大小的指针,其余的保持不变.</p>
</li>
<li><p class="startli"><a class="el" href="../../d3/d63/classcv_1_1Mat.html#a55ced2c8d844d683ea9a725c60037ad0">cv::Mat::create</a>功能:</p>
<div class="fragment"><div class="line">    M.create(4,4, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga78c5506f62d99edd7e83aba259250394">CV_8UC</a>(2));</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;M = &quot;</span>&lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span>  &lt;&lt; M &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut2.png" alt="MatBasicContainerOut2.png">
</div>
<p class="startli">不能使用此构造初始化矩阵值.它只会重新分配其矩阵数据内存,如果新的大小不适合旧的.</p>
</li>
<li><p class="startli">MATLAB风格的初始值设定项:<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a0b57b6a326c8876d944d188a46e0f556">cv::Mat::zeros</a>,<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a69ae0402d116fc9c71908d8508dc2f09">cv::Mat::ones</a>,<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a2cf9b9acde7a9852542bbc20ef851ed2">cv::Mat::eye</a>. 指定要使用的大小和数据类型:</p>
<div class="fragment"><div class="line">    Mat E = Mat::eye(4, 4, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga30a562691cc5987bc88eb7bb7a8faf2b">CV_64F</a>);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;E = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    Mat O = Mat::ones(2, 2, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a>);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;O = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</div><div class="line">    Mat Z = Mat::zeros(3,3, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Z = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut3.png" alt="MatBasicContainerOut3.png">
</div>
</li>
<li><p class="startli">对于小矩阵,可以使用逗号分隔的初始化器或初始化列表(在最后一种情况下需要C++ 11支持):</p>
<div class="fragment"><div class="line">    Mat C = (Mat_&lt;double&gt;(3,3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;C = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; C &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="fragment"><div class="line">    C = (Mat_&lt;double&gt;({0, -1, 0, -1, 5, -1, 0, -1, 0})).reshape(3);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;C = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; C &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut6.png" alt="MatBasicContainerOut6.png">
</div>
</li>
<li><p class="startli">为现有标题创建新标题<em>Mat</em>对象和<a class="el" href="../../d3/d63/classcv_1_1Mat.html#adff2ea98da45eae0833e73582dd4a660">cv::Mat::clone</a>或<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">cv::Mat::copyTo</a>是的.</p>
<div class="fragment"><div class="line">    Mat RowClone = C.row(1).clone();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;RowClone = &quot;</span> &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; RowClone &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut7.png" alt="MatBasicContainerOut7.png">
</div>
<dl class="section note"><dt>Note</dt><dd>您可以使用<a class="el" href="../../d2/de8/group__core__array.html#ga1ba1026dca0807b27057ba6a49d258c0">cv::randu()</a>功能.您需要给出随机值的下限和上限:<div class="fragment"><div class="line">    Mat R = Mat(3, 2, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga1ba1026dca0807b27057ba6a49d258c0">randu</a>(R, Scalar::all(0), Scalar::all(255));</div></div><!-- fragment --></dd></dl>
<h2>输出格式</h2>
</li>
</ul>
<p>在上面的示例中,您可以看到默认的格式化选项.不过,OpenCV允许您格式化矩阵输出:</p>
<ul>
<li>默认<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;R (default) = &quot;</span> &lt;&lt; endl &lt;&lt;        R           &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut8.png" alt="MatBasicContainerOut8.png">
</div>
</li>
<li>Python<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;R (python)  = &quot;</span> &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_PYTHON) &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut16.png" alt="MatBasicContainerOut16.png">
</div>
</li>
<li>Comma separated values (CSV)<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;R (csv)     = &quot;</span> &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_CSV   ) &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut10.png" alt="MatBasicContainerOut10.png">
</div>
</li>
<li>Numpy<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;R (numpy)   = &quot;</span> &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_NUMPY ) &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut9.png" alt="MatBasicContainerOut9.png">
</div>
</li>
<li>C<div class="fragment"><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;R (c)       = &quot;</span> &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_C     ) &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut11.png" alt="MatBasicContainerOut11.png">
</div>
</li>
</ul>
<h2>其他常用项输出</h2>
<p>OpenCV还通过&lt;提供对其他常见OpenCV数据结构输出的支持&书信电报;操作员:</p>
<ul>
<li>二维点<div class="fragment"><div class="line">    <a class="code" href="../../dc/d84/group__core__basic.html#ga7d080aa40de011e4410bca63385ffe2a">Point2f</a> P(5, 1);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Point (2D) = &quot;</span> &lt;&lt; P &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut12.png" alt="MatBasicContainerOut12.png">
</div>
</li>
<li>三维点<div class="fragment"><div class="line">    <a class="code" href="../../dc/d84/group__core__basic.html#ga3d79ceeb4419bccd0308dfdf1cd31435">Point3f</a> P3f(2, 6, 7);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Point (3D) = &quot;</span> &lt;&lt; P3f &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut13.png" alt="MatBasicContainerOut13.png">
</div>
</li>
<li>std::vector via<a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">cv::Mat</a> <div class="fragment"><div class="line">    vector&lt;float&gt; v;</div><div class="line">    v.push_back( (<span class="keywordtype">float</span>)<a class="code" href="../../db/de0/group__core__utils.html#ga677b89fae9308b340ddaebf0dba8455f">CV_PI</a>);   v.push_back(2);    v.push_back(3.01f);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Vector of floats via Mat = &quot;</span> &lt;&lt; Mat(v) &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut14.png" alt="MatBasicContainerOut14.png">
</div>
</li>
<li>std::vector of points<div class="fragment"><div class="line">    vector&lt;Point2f&gt; vPoints(20);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vPoints.size(); ++i)</div><div class="line">        vPoints[i] = <a class="code" href="../../dc/d84/group__core__basic.html#ga7d080aa40de011e4410bca63385ffe2a">Point2f</a>((<span class="keywordtype">float</span>)(i * 5), (<span class="keywordtype">float</span>)(i % 7));</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A vector of 2D Points = &quot;</span> &lt;&lt; vPoints &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --> <div class="image">
<img src="../../MatBasicContainerOut15.png" alt="MatBasicContainerOut15.png">
</div>
</li>
</ul>
<p>这里的大多数示例都包含在一个小型控制台应用程序中.你可以从<a href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/core/mat_the_basic_image_container/mat_the_basic_image_container.cpp">在这里</a>或者在cpp样本的核心部分.</p>
<p>你也可以在网上找到一个快速的视频演示<a href="https://www.youtube.com/watch?v=1tibU7vGWpk">YouTube</a>.</p>
<div align="center"><iframe title="Video" width="560" height="349" src="https://www.youtube.com/embed/1tibU7vGWpk?rel=0" frameborder="0" align="middle" allowfullscreen=""></iframe></div> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"><address class="footer"><small>Generated on Fri Apr 2 2021 11:36:34 for OpenCV by zsz<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen">
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
