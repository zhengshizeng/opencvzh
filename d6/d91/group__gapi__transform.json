[
  {
    "origin": "OpenCV: Graph API: Image and channel composition functions",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "Graph API: Image and channel composition functions",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src1, const",
    "local": ""
  },
  {
    "origin": "&amp;src2)",
    "local": ""
  },
  {
    "origin": "Applies horizontal concatenation to given matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;v)",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src1, const",
    "local": ""
  },
  {
    "origin": "&amp;src2)",
    "local": ""
  },
  {
    "origin": "Applies vertical concatenation to given matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;v)",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int rdepth, double alpha=1, double beta=0)",
    "local": ""
  },
  {
    "origin": "Converts a matrix to another data depth with optional scaling.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;in)",
    "local": ""
  },
  {
    "origin": "Makes a copy of the input image. Note that this copy may be not real (no actual data copied). Use this function to maintain graph contracts, e.g when graph's input needs to be passed directly to output, like in Streaming mode.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;in)",
    "local": ""
  },
  {
    "origin": "Makes a copy of the input frame. Note that this copy may be not real (no actual data copied). Use this function to maintain graph contracts, e.g when graph's input needs to be passed directly to output, like in Streaming mode.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;rect)",
    "local": ""
  },
  {
    "origin": "Crops a 2D matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int flipCode)",
    "local": ""
  },
  {
    "origin": "Flips a 2D matrix around vertical, horizontal, or both axes.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;lut)",
    "local": ""
  },
  {
    "origin": "Performs a look-up table transform of a matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src1, const",
    "local": ""
  },
  {
    "origin": "&amp;src2, const",
    "local": ""
  },
  {
    "origin": "&amp;src3)",
    "local": ""
  },
  {
    "origin": "Creates one 3-channel matrix out of 3 single-channel ones.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src1, const",
    "local": ""
  },
  {
    "origin": "&amp;src2, const",
    "local": ""
  },
  {
    "origin": "&amp;src3, const",
    "local": ""
  },
  {
    "origin": "&amp;src4)",
    "local": ""
  },
  {
    "origin": "Creates one 4-channel matrix out of 4 single-channel ones.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, double alpha, double beta, int norm_type, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Normalizes the norm or value range of an array.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;map1, const",
    "local": ""
  },
  {
    "origin": "&amp;map2, int interpolation, int borderMode=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies a generic geometrical transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;dsize, double fx=0, double fy=0, int interpolation=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;dsize, int interpolation=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes a planar image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "std::tuple&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src)",
    "local": ""
  },
  {
    "origin": "Divides a 3-channel matrix into 3 single-channel matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "std::tuple&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src)",
    "local": ""
  },
  {
    "origin": "Divides a 4-channel matrix into 4 single-channel matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;M, const",
    "local": ""
  },
  {
    "origin": "&amp;dsize, int flags=",
    "local": ""
  },
  {
    "origin": ", int borderMode=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies an affine transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;M, const",
    "local": ""
  },
  {
    "origin": "&amp;dsize, int flags=",
    "local": ""
  },
  {
    "origin": ", int borderMode=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies a perspective transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "concatHor()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::gapi::concatHor",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies horizontal concatenation to given matrices.",
    "local": ""
  },
  {
    "origin": "The function horizontally concatenates two",
    "local": ""
  },
  {
    "origin": "matrices (with the same number of rows).",
    "local": ""
  },
  {
    "origin": "Output matrix must the same number of rows and depth as the src1 and src2, and the sum of cols of the src1 and src2. Supported matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.transform.concatHor\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "first input matrix to be considered for horizontal concatenation.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "second input matrix to be considered for horizontal concatenation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "concatHor()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::gapi::concatHor",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "v",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. The function horizontally concatenates given number of",
    "local": ""
  },
  {
    "origin": "matrices (with the same number of columns). Output matrix must the same number of columns and depth as the input matrices, and the sum of rows of input matrices.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "v",
    "local": ""
  },
  {
    "origin": "vector of input matrices to be concatenated horizontally.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "concatVert()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::gapi::concatVert",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies vertical concatenation to given matrices.",
    "local": ""
  },
  {
    "origin": "The function vertically concatenates two",
    "local": ""
  },
  {
    "origin": "matrices (with the same number of cols).",
    "local": ""
  },
  {
    "origin": "Output matrix must the same number of cols and depth as the src1 and src2, and the sum of rows of the src1 and src2. Supported matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.transform.concatVert\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "first input matrix to be considered for vertical concatenation.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "second input matrix to be considered for vertical concatenation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "concatVert()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::gapi::concatVert",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "v",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. The function vertically concatenates given number of",
    "local": ""
  },
  {
    "origin": "matrices (with the same number of columns). Output matrix must the same number of columns and depth as the input matrices, and the sum of rows of input matrices.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "v",
    "local": ""
  },
  {
    "origin": "vector of input matrices to be concatenated vertically.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "convertTo()",
    "local": ""
  },
  {
    "origin": "cv::gapi::convertTo",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "rdepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "alpha",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Converts a matrix to another data depth with optional scaling.",
    "local": ""
  },
  {
    "origin": "The method converts source pixel values to the target data depth. saturate_cast&lt;&gt; is applied at the end to avoid possible overflows:",
    "local": ""
  },
  {
    "origin": "\\[m(x,y) = saturate \\_ cast&lt;rType&gt;( \\alpha (*this)(x,y) + \\beta )\\]",
    "local": ""
  },
  {
    "origin": "Output matrix must be of the same size as input one.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.convertTo\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input matrix to be converted from.",
    "local": ""
  },
  {
    "origin": "rdepth",
    "local": ""
  },
  {
    "origin": "desired output matrix depth or, rather, the depth since the number of channels are the same as the input has; if rdepth is negative, the output matrix will have the same depth as the input.",
    "local": ""
  },
  {
    "origin": "alpha",
    "local": ""
  },
  {
    "origin": "optional scale factor.",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "optional delta added to the scaled values.",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "copy()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::gapi::copy",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "in",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Makes a copy of the input image. Note that this copy may be not real (no actual data copied). Use this function to maintain graph contracts, e.g when graph's input needs to be passed directly to output, like in Streaming mode.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.streaming.copy\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "in",
    "local": ""
  },
  {
    "origin": "Input image",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Copy of the input",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "copy()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::gapi::copy",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "in",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Makes a copy of the input frame. Note that this copy may be not real (no actual data copied). Use this function to maintain graph contracts, e.g when graph's input needs to be passed directly to output, like in Streaming mode.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.streaming.copy\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "in",
    "local": ""
  },
  {
    "origin": "Input frame",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Copy of the input",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "crop()",
    "local": ""
  },
  {
    "origin": "cv::gapi::crop",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "rect",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Crops a 2D matrix.",
    "local": ""
  },
  {
    "origin": "The function crops the matrix by given",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Output matrix must be of the same depth as input one, size is specified by given rect size.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.crop\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input matrix.",
    "local": ""
  },
  {
    "origin": "rect",
    "local": ""
  },
  {
    "origin": "a rect to crop a matrix to",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "flip()",
    "local": ""
  },
  {
    "origin": "cv::gapi::flip",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flipCode",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Flips a 2D matrix around vertical, horizontal, or both axes.",
    "local": ""
  },
  {
    "origin": "The function flips the matrix in one of three different ways (row and column indices are 0-based):",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} _{ij} = \\left\\{ \\begin{array}{l l} \\texttt{src} _{\\texttt{src.rows}-i-1,j} &amp; if\\; \\texttt{flipCode} = 0 \\\\ \\texttt{src} _{i, \\texttt{src.cols} -j-1} &amp; if\\; \\texttt{flipCode} &gt; 0 \\\\ \\texttt{src} _{ \\texttt{src.rows} -i-1, \\texttt{src.cols} -j-1} &amp; if\\; \\texttt{flipCode} &lt; 0 \\\\ \\end{array} \\right.\\]",
    "local": ""
  },
  {
    "origin": "The example scenarios of using the function are the following: Vertical flipping of the image (flipCode == 0) to switch between top-left and bottom-left image origin. This is a typical operation in video processing on Microsoft Windows* OS. Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-axis symmetry (flipCode &gt; 0). Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry (flipCode &lt; 0). Reversing the order of point arrays (flipCode &gt; 0 or flipCode == 0). Output image must be of the same depth as input one, size should be correct for given flipCode.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.flip\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input matrix.",
    "local": ""
  },
  {
    "origin": "flipCode",
    "local": ""
  },
  {
    "origin": "a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "LUT()",
    "local": ""
  },
  {
    "origin": "cv::gapi::LUT",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "lut",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs a look-up table transform of a matrix.",
    "local": ""
  },
  {
    "origin": "The function LUT fills the output matrix with values from the look-up table. Indices of the entries are taken from the input matrix. That is, the function processes each element of src as follows:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (I) \\leftarrow \\texttt{lut(src(I))}\\]",
    "local": ""
  },
  {
    "origin": "Supported matrix data types are",
    "local": ""
  },
  {
    "origin": ". Output is a matrix of the same size and number of channels as src, and the same depth as lut.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.LUT\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input matrix of 8-bit elements.",
    "local": ""
  },
  {
    "origin": "lut",
    "local": ""
  },
  {
    "origin": "look-up table of 256 elements; in case of multi-channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input matrix.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "merge3()",
    "local": ""
  },
  {
    "origin": "cv::gapi::merge3",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src3",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates one 3-channel matrix out of 3 single-channel ones.",
    "local": ""
  },
  {
    "origin": "The function merges several matrices to make a single multi-channel matrix. That is, each element of the output matrix will be a concatenation of the elements of the input matrices, where elements of i-th input matrix are treated as mv[i].channels()-element vectors. Output matrix must be of",
    "local": ""
  },
  {
    "origin": "type.",
    "local": ""
  },
  {
    "origin": "The function split3 does the reverse operation.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.merge3\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "first input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "second input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "src3",
    "local": ""
  },
  {
    "origin": "third input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "merge4()",
    "local": ""
  },
  {
    "origin": "cv::gapi::merge4",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src3",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src4",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates one 4-channel matrix out of 4 single-channel ones.",
    "local": ""
  },
  {
    "origin": "The function merges several matrices to make a single multi-channel matrix. That is, each element of the output matrix will be a concatenation of the elements of the input matrices, where elements of i-th input matrix are treated as mv[i].channels()-element vectors. Output matrix must be of",
    "local": ""
  },
  {
    "origin": "type.",
    "local": ""
  },
  {
    "origin": "The function split4 does the reverse operation.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.merge4\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src1",
    "local": ""
  },
  {
    "origin": "first input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "src2",
    "local": ""
  },
  {
    "origin": "second input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "src3",
    "local": ""
  },
  {
    "origin": "third input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "src4",
    "local": ""
  },
  {
    "origin": "fourth input",
    "local": ""
  },
  {
    "origin": "matrix to be merged.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "normalize()",
    "local": ""
  },
  {
    "origin": "cv::gapi::normalize",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "alpha",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "norm_type",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Normalizes the norm or value range of an array.",
    "local": ""
  },
  {
    "origin": "The function normalizes scale and shift the input array elements so that",
    "local": ""
  },
  {
    "origin": "\\[\\| \\texttt{dst} \\| _{L_p}= \\texttt{alpha}\\]",
    "local": ""
  },
  {
    "origin": "(where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that",
    "local": ""
  },
  {
    "origin": "\\[\\min _I \\texttt{dst} (I)= \\texttt{alpha} , \\, \\, \\max _I \\texttt{dst} (I)= \\texttt{beta}\\]",
    "local": ""
  },
  {
    "origin": "when normType=NORM_MINMAX (for dense arrays only).",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.normalize\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input array.",
    "local": ""
  },
  {
    "origin": "alpha",
    "local": ""
  },
  {
    "origin": "norm value to normalize to or the lower range boundary in case of the range normalization.",
    "local": ""
  },
  {
    "origin": "beta",
    "local": ""
  },
  {
    "origin": "upper range boundary in case of the range normalization; it is not used for the norm normalization.",
    "local": ""
  },
  {
    "origin": "norm_type",
    "local": ""
  },
  {
    "origin": "normalization type (see",
    "local": ""
  },
  {
    "origin": ").",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =ddepth.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "remap()",
    "local": ""
  },
  {
    "origin": "cv::gapi::remap",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "map1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "map2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies a generic geometrical transformation to an image.",
    "local": ""
  },
  {
    "origin": "The function remap transforms the source image using the specified map:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\texttt{src} (map_x(x,y),map_y(x,y))\\]",
    "local": ""
  },
  {
    "origin": "where values of pixels with non-integer coordinates are computed using one of available interpolation methods. \\(map_x\\) and \\(map_y\\) can be encoded as separate floating-point maps in \\(map_1\\) and \\(map_2\\) respectively, or interleaved floating-point maps of \\((x,y)\\) in \\(map_1\\), or fixed-point maps created by using convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (2x) remapping operations. In the converted case, \\(map_1\\) contains pairs (cvFloor(x), cvFloor(y)) and \\(map_2\\) contains indices in a table of interpolation coefficients. Output image must be of the same size and depth as input one.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.remap\"",
    "local": ""
  },
  {
    "origin": "Due to current implementation limitations the size of an input and output images should be less than 32767x32767.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "map1",
    "local": ""
  },
  {
    "origin": "The first map of either (x,y) points or just x values having the type CV_16SC2, CV_32FC1, or CV_32FC2.",
    "local": ""
  },
  {
    "origin": "map2",
    "local": ""
  },
  {
    "origin": "The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "Interpolation method (see",
    "local": ""
  },
  {
    "origin": "). The methods",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "are not supported by this function.",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "Pixel extrapolation method (see",
    "local": ""
  },
  {
    "origin": "). When borderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the \"outliers\" in the source image are not modified by the function.",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "resize()",
    "local": ""
  },
  {
    "origin": "cv::gapi::resize",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "fx",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "fy",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes an image.",
    "local": ""
  },
  {
    "origin": "The function resizes the image src down to or up to the specified size.",
    "local": ""
  },
  {
    "origin": "Output image size will have the size dsize (when dsize is non-zero) or the size computed from",
    "local": ""
  },
  {
    "origin": ", fx, and fy; the depth of output is the same as of src.",
    "local": ""
  },
  {
    "origin": "If you want to resize src so that it fits the pre-created dst, you may call the function as follows:",
    "local": ""
  },
  {
    "origin": "If you want to decimate the image by factor of 2 in each direction, you can call the function this way:",
    "local": ""
  },
  {
    "origin": "To shrink an image, it will generally look best with",
    "local": ""
  },
  {
    "origin": "interpolation, whereas to enlarge an image, it will generally look best with",
    "local": ""
  },
  {
    "origin": "(slow) or",
    "local": ""
  },
  {
    "origin": "(faster but still looks OK).",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.resize\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "output image size; if it equals zero, it is computed as:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\]",
    "local": ""
  },
  {
    "origin": "Either dsize or both fx and fy must be non-zero.",
    "local": ""
  },
  {
    "origin": "fx",
    "local": ""
  },
  {
    "origin": "scale factor along the horizontal axis; when it equals 0, it is computed as",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{(double)dsize.width/src.cols}\\]",
    "local": ""
  },
  {
    "origin": "fy",
    "local": ""
  },
  {
    "origin": "scale factor along the vertical axis; when it equals 0, it is computed as",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{(double)dsize.height/src.rows}\\]",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "interpolation method, see",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "resizeP()",
    "local": ""
  },
  {
    "origin": "cv::gapi::resizeP",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes a planar image.",
    "local": ""
  },
  {
    "origin": "The function resizes the image src down to or up to the specified size. Planar image memory layout is three planes laying in the memory contiguously, so the image height should be plane_height*plane_number, image type is",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Output image size will have the size dsize, the depth of output is the same as of src.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.resizeP\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image, must be of",
    "local": ""
  },
  {
    "origin": "type;",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "output image size;",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "interpolation method, only",
    "local": ""
  },
  {
    "origin": "is supported at the moment",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "split3()",
    "local": ""
  },
  {
    "origin": "std::tuple&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt; cv::gapi::split3",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.gapi.split3(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Divides a 3-channel matrix into 3 single-channel matrices.",
    "local": ""
  },
  {
    "origin": "The function splits a 3-channel matrix into 3 single-channel matrices:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{mv} [c](I) = \\texttt{src} (I)_c\\]",
    "local": ""
  },
  {
    "origin": "All output matrices must be of",
    "local": ""
  },
  {
    "origin": "type.",
    "local": ""
  },
  {
    "origin": "The function merge3 does the reverse operation.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.split3\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input",
    "local": ""
  },
  {
    "origin": "matrix.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "split4()",
    "local": ""
  },
  {
    "origin": "std::tuple&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt; cv::gapi::split4",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Divides a 4-channel matrix into 4 single-channel matrices.",
    "local": ""
  },
  {
    "origin": "The function splits a 4-channel matrix into 4 single-channel matrices:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{mv} [c](I) = \\texttt{src} (I)_c\\]",
    "local": ""
  },
  {
    "origin": "All output matrices must be of",
    "local": ""
  },
  {
    "origin": "type.",
    "local": ""
  },
  {
    "origin": "The function merge4 does the reverse operation.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.core.transform.split4\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input",
    "local": ""
  },
  {
    "origin": "matrix.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "warpAffine()",
    "local": ""
  },
  {
    "origin": "cv::gapi::warpAffine",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies an affine transformation to an image.",
    "local": ""
  },
  {
    "origin": "The function warpAffine transforms the source image using the specified matrix:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\texttt{src} ( \\texttt{M} _{11} x + \\texttt{M} _{12} y + \\texttt{M} _{13}, \\texttt{M} _{21} x + \\texttt{M} _{22} y + \\texttt{M} _{23})\\]",
    "local": ""
  },
  {
    "origin": "when the flag",
    "local": ""
  },
  {
    "origin": "is set. Otherwise, the transformation is first inverted with",
    "local": ""
  },
  {
    "origin": "and then put in the formula above instead of M. The function cannot operate in-place.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "\\(2\\times 3\\) transformation matrix.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "size of the output image.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "combination of interpolation methods (see",
    "local": ""
  },
  {
    "origin": ") and the optional flag",
    "local": ""
  },
  {
    "origin": "that means that M is the inverse transformation ( \\(\\texttt{dst}\\rightarrow\\texttt{src}\\) ).",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method (see",
    "local": ""
  },
  {
    "origin": "); borderMode=",
    "local": ""
  },
  {
    "origin": "isn't supported",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "warpPerspective()",
    "local": ""
  },
  {
    "origin": "cv::gapi::warpPerspective",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies a perspective transformation to an image.",
    "local": ""
  },
  {
    "origin": "The function warpPerspective transforms the source image using the specified matrix:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\texttt{src} \\left ( \\frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \\right )\\]",
    "local": ""
  },
  {
    "origin": "when the flag",
    "local": ""
  },
  {
    "origin": "is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "\\(3\\times 3\\) transformation matrix.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "size of the output image.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "combination of interpolation methods (",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": ") and the optional flag",
    "local": ""
  },
  {
    "origin": ", that sets M as the inverse transformation ( \\(\\texttt{dst}\\rightarrow\\texttt{src}\\) ).",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method (",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": ").",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:41 for OpenCV by",
    "local": ""
  }
]