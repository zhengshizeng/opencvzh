[
  {
    "origin": "OpenCV: Deep Neural Network module",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Modules",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Typedefs",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "Deep Neural Network module",
    "local": ""
  },
  {
    "origin": "Modules",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Derivatives of this class encapsulates functions of certain backends.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Derivatives of this class wraps",
    "local": ""
  },
  {
    "origin": "for different backends and targets.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for classification models.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for object detection networks.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class implements name-value dictionary, values are instances of",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "struct",
    "local": ""
  },
  {
    "origin": "This struct stores the scalar value (or array) of one of the following type: double,",
    "local": ""
  },
  {
    "origin": "or int64.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for keypoints models.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This interface class allows to build new Layers - are building blocks of networks.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class provides all data needed to initialize layer.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class is presented high-level API for neural networks.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class allows to create and manipulate comprehensive artificial neural networks.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for segmentation models.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "Base class for text detection networks.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for text detection DL networks compatible with DB model.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for text detection DL networks compatible with EAST model.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "This class represents high-level API for text recognition networks.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Typedefs",
    "local": ""
  },
  {
    "origin": "typedef std::map&lt; std::string, std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &gt;",
    "local": ""
  },
  {
    "origin": "Register layer types of DNN model.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "typedef std::vector&lt; int &gt;",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Enum of computation backends supported by layers.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Enum of target devices for computations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image, double scalefactor=1.0, const",
    "local": ""
  },
  {
    "origin": "&amp;size=",
    "local": ""
  },
  {
    "origin": "(), const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "(), bool swapRB=false, bool crop=false, int ddepth=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from image. Optionally resizes and crops",
    "local": ""
  },
  {
    "origin": "from center, subtract",
    "local": ""
  },
  {
    "origin": "values, scales values by",
    "local": ""
  },
  {
    "origin": ", swap Blue and Red channels.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "blob, double scalefactor=1.0, const",
    "local": ""
  },
  {
    "origin": "&amp;size=",
    "local": ""
  },
  {
    "origin": "(), const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "(), bool swapRB=false, bool crop=false, int ddepth=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "images, double scalefactor=1.0,",
    "local": ""
  },
  {
    "origin": "size=",
    "local": ""
  },
  {
    "origin": "(), const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "(), bool swapRB=false, bool crop=false, int ddepth=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from series of images. Optionally resizes and crops",
    "local": ""
  },
  {
    "origin": "from center, subtract",
    "local": ""
  },
  {
    "origin": "values, scales values by",
    "local": ""
  },
  {
    "origin": ", swap Blue and Red channels.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "images,",
    "local": ""
  },
  {
    "origin": "blob, double scalefactor=1.0,",
    "local": ""
  },
  {
    "origin": "size=",
    "local": ""
  },
  {
    "origin": "(), const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "(), bool swapRB=false, bool crop=false, int ddepth=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from series of images.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(bool isDiagnosticsMode)",
    "local": ""
  },
  {
    "origin": "Enables detailed logging of the DNN model loading with CV DNN API.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "std::vector&lt; std::pair&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt; &gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "be)",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;blob_,",
    "local": ""
  },
  {
    "origin": "images_)",
    "local": ""
  },
  {
    "origin": "Parse a 4D blob and output the images it contains as 2D arrays through a simpler data structure (std::vector&lt;cv::Mat&gt;).",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bboxes, const std::vector&lt; float &gt; &amp;scores, const float score_threshold, const float nms_threshold, std::vector&lt; int &gt; &amp;indices, const float eta=1.f, const int top_k=0)",
    "local": ""
  },
  {
    "origin": "Performs non maximum suppression given boxes and corresponding scores.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bboxes, const std::vector&lt; float &gt; &amp;scores, const float score_threshold, const float nms_threshold, std::vector&lt; int &gt; &amp;indices, const float eta=1.f, const int top_k=0)",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bboxes, const std::vector&lt; float &gt; &amp;scores, const float score_threshold, const float nms_threshold, std::vector&lt; int &gt; &amp;indices, const float eta=1.f, const int top_k=0)",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;model, const",
    "local": ""
  },
  {
    "origin": "&amp;config=\"\", const",
    "local": ""
  },
  {
    "origin": "&amp;framework=\"\")",
    "local": ""
  },
  {
    "origin": "Read deep learning network represented in one of the supported formats.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;framework, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferModel, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferConfig=std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;())",
    "local": ""
  },
  {
    "origin": "Read deep learning network represented in one of the supported formats.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;prototxt, const",
    "local": ""
  },
  {
    "origin": "&amp;caffeModel=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Caffe",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferProto, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferModel=std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;())",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in Caffe model in memory.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const char *bufferProto, size_t lenProto, const char *bufferModel=NULL, size_t lenModel=0)",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in Caffe model in memory.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;cfgFile, const",
    "local": ""
  },
  {
    "origin": "&amp;darknetModel=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Darknet",
    "local": ""
  },
  {
    "origin": "model files.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferCfg, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferModel=std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;())",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Darknet",
    "local": ""
  },
  {
    "origin": "model files.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const char *bufferCfg, size_t lenCfg, const char *bufferModel=NULL, size_t lenModel=0)",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Darknet",
    "local": ""
  },
  {
    "origin": "model files.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;xml, const",
    "local": ""
  },
  {
    "origin": "&amp;bin)",
    "local": ""
  },
  {
    "origin": "Load a network from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer intermediate representation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferModelConfig, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferWeights)",
    "local": ""
  },
  {
    "origin": "Load a network from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer intermediate representation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "*bufferModelConfigPtr, size_t bufferModelConfigSize, const",
    "local": ""
  },
  {
    "origin": "*bufferWeightsPtr, size_t bufferWeightsSize)",
    "local": ""
  },
  {
    "origin": "Load a network from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer intermediate representation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;onnxFile)",
    "local": ""
  },
  {
    "origin": "Reads a network model",
    "local": ""
  },
  {
    "origin": "ONNX",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const char *buffer, size_t sizeBuffer)",
    "local": ""
  },
  {
    "origin": "Reads a network model from",
    "local": ""
  },
  {
    "origin": "ONNX",
    "local": ""
  },
  {
    "origin": "in-memory buffer.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;buffer)",
    "local": ""
  },
  {
    "origin": "Reads a network model from",
    "local": ""
  },
  {
    "origin": "ONNX",
    "local": ""
  },
  {
    "origin": "in-memory buffer.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;model, const",
    "local": ""
  },
  {
    "origin": "&amp;config=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "TensorFlow",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferModel, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;bufferConfig=std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;())",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "TensorFlow",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const char *bufferModel, size_t lenModel, const char *bufferConfig=NULL, size_t lenConfig=0)",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "TensorFlow",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;model, bool isBinary=true, bool evaluate=true)",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Torch7",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;path)",
    "local": ""
  },
  {
    "origin": "Creates blob from .pb file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename, bool isBinary=true)",
    "local": ""
  },
  {
    "origin": "Loads blob which was serialized as torch.Tensor object of Torch7 framework.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;dst, const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;layersTypes=std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;())",
    "local": ""
  },
  {
    "origin": "Convert all weights of Caffe network to half precision floating point.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;model, const",
    "local": ""
  },
  {
    "origin": "&amp;output)",
    "local": ""
  },
  {
    "origin": "Create a text representation for a binary network stored in protocol buffer format.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "This module contains:",
    "local": ""
  },
  {
    "origin": "API for new layers creation, layers are building bricks of neural networks;",
    "local": ""
  },
  {
    "origin": "set of built-in most-useful Layers;",
    "local": ""
  },
  {
    "origin": "API to construct and modify comprehensive neural networks from layers;",
    "local": ""
  },
  {
    "origin": "functionality for loading serialized networks models from different frameworks.",
    "local": ""
  },
  {
    "origin": "Functionality of this module is designed only for forward pass computations (i.e. network testing). A network training is in principle not supported.",
    "local": ""
  },
  {
    "origin": "Typedef Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "LayerFactory_Impl",
    "local": ""
  },
  {
    "origin": "typedef std::map&lt;std::string, std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &gt;",
    "local": ""
  },
  {
    "origin": "Register layer types of DNN model.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "MatShape",
    "local": ""
  },
  {
    "origin": "typedef std::vector&lt;int&gt;",
    "local": ""
  },
  {
    "origin": "Enumeration Type Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "Backend",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Enum of computation backends supported by layers.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_DEFAULT",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_BACKEND_DEFAULT",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_DEFAULT equals to DNN_BACKEND_INFERENCE_ENGINE if OpenCV is built with Intel's Inference Engine library or DNN_BACKEND_OPENCV otherwise.",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_HALIDE",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_BACKEND_HALIDE",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_INFERENCE_ENGINE",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_BACKEND_INFERENCE_ENGINE",
    "local": ""
  },
  {
    "origin": "Intel's Inference Engine computational backend",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_OPENCV",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_BACKEND_OPENCV",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_VKCOM",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_BACKEND_VKCOM",
    "local": ""
  },
  {
    "origin": "DNN_BACKEND_CUDA",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_BACKEND_CUDA",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "Target",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Enum of target devices for computations.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_CPU",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_CPU",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_OPENCL",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_OPENCL",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_OPENCL_FP16",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_OPENCL_FP16",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_MYRIAD",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_MYRIAD",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_VULKAN",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_VULKAN",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_FPGA",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_FPGA",
    "local": ""
  },
  {
    "origin": "FPGA device with CPU fallbacks using Inference Engine's Heterogeneous plugin.",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_CUDA",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_CUDA",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_CUDA_FP16",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_CUDA_FP16",
    "local": ""
  },
  {
    "origin": "DNN_TARGET_HDDL",
    "local": ""
  },
  {
    "origin": "Python: cv.dnn.DNN_TARGET_HDDL",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "blobFromImage()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::dnn::blobFromImage",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scalefactor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "mean",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "swapRB",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "crop",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.blobFromImage(",
    "local": ""
  },
  {
    "origin": "image[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from image. Optionally resizes and crops",
    "local": ""
  },
  {
    "origin": "from center, subtract",
    "local": ""
  },
  {
    "origin": "values, scales values by",
    "local": ""
  },
  {
    "origin": ", swap Blue and Red channels.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "input image (with 1-, 3- or 4-channels).",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "spatial size for output image",
    "local": ""
  },
  {
    "origin": "mean",
    "local": ""
  },
  {
    "origin": "scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if",
    "local": ""
  },
  {
    "origin": "has BGR ordering and",
    "local": ""
  },
  {
    "origin": "is true.",
    "local": ""
  },
  {
    "origin": "scalefactor",
    "local": ""
  },
  {
    "origin": "multiplier for",
    "local": ""
  },
  {
    "origin": "values.",
    "local": ""
  },
  {
    "origin": "swapRB",
    "local": ""
  },
  {
    "origin": "flag which indicates that swap first and last channels in 3-channel image is necessary.",
    "local": ""
  },
  {
    "origin": "crop",
    "local": ""
  },
  {
    "origin": "flag which indicates whether image will be cropped after resize or not",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "Depth of output blob. Choose CV_32F or CV_8U.",
    "local": ""
  },
  {
    "origin": "if",
    "local": ""
  },
  {
    "origin": "is true, input image is resized so one side after resize is equal to corresponding dimension in",
    "local": ""
  },
  {
    "origin": "and another one is equal or larger. Then, crop from the center is performed. If",
    "local": ""
  },
  {
    "origin": "is false, direct resize without cropping and preserving aspect ratio is performed.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "4-dimensional",
    "local": ""
  },
  {
    "origin": "with NCHW dimensions order.",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "blobFromImage()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "void cv::dnn::blobFromImage",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "blob",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scalefactor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "mean",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "swapRB",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "crop",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.blobFromImage(",
    "local": ""
  },
  {
    "origin": "image[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from image.",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "blobFromImages()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::dnn::blobFromImages",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "images",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scalefactor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "mean",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "swapRB",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "crop",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.blobFromImages(",
    "local": ""
  },
  {
    "origin": "images[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from series of images. Optionally resizes and crops",
    "local": ""
  },
  {
    "origin": "from center, subtract",
    "local": ""
  },
  {
    "origin": "values, scales values by",
    "local": ""
  },
  {
    "origin": ", swap Blue and Red channels.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "images",
    "local": ""
  },
  {
    "origin": "input images (all with 1-, 3- or 4-channels).",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "spatial size for output image",
    "local": ""
  },
  {
    "origin": "mean",
    "local": ""
  },
  {
    "origin": "scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if",
    "local": ""
  },
  {
    "origin": "has BGR ordering and",
    "local": ""
  },
  {
    "origin": "is true.",
    "local": ""
  },
  {
    "origin": "scalefactor",
    "local": ""
  },
  {
    "origin": "multiplier for",
    "local": ""
  },
  {
    "origin": "values.",
    "local": ""
  },
  {
    "origin": "swapRB",
    "local": ""
  },
  {
    "origin": "flag which indicates that swap first and last channels in 3-channel image is necessary.",
    "local": ""
  },
  {
    "origin": "crop",
    "local": ""
  },
  {
    "origin": "flag which indicates whether image will be cropped after resize or not",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "Depth of output blob. Choose CV_32F or CV_8U.",
    "local": ""
  },
  {
    "origin": "if",
    "local": ""
  },
  {
    "origin": "is true, input image is resized so one side after resize is equal to corresponding dimension in",
    "local": ""
  },
  {
    "origin": "and another one is equal or larger. Then, crop from the center is performed. If",
    "local": ""
  },
  {
    "origin": "is false, direct resize without cropping and preserving aspect ratio is performed.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "4-dimensional",
    "local": ""
  },
  {
    "origin": "with NCHW dimensions order.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "blobFromImages()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "void cv::dnn::blobFromImages",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "images",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "blob",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scalefactor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "mean",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "swapRB",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "crop",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.blobFromImages(",
    "local": ""
  },
  {
    "origin": "images[, scalefactor[, size[, mean[, swapRB[, crop[, ddepth]]]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates 4-dimensional blob from series of images.",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "enableModelDiagnostics()",
    "local": ""
  },
  {
    "origin": "void cv::dnn::enableModelDiagnostics",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "isDiagnosticsMode",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Enables detailed logging of the DNN model loading with CV DNN API.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "isDiagnosticsMode",
    "local": ""
  },
  {
    "origin": "Indicates whether diagnostic mode should be set.",
    "local": ""
  },
  {
    "origin": "Diagnostic mode provides detailed logging of the model loading stage to explore potential problems (ex.: not implemented layer type).",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "In diagnostic mode series of assertions will be skipped, it can lead to the expected application crash.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getAvailableBackends()",
    "local": ""
  },
  {
    "origin": "std::vector&lt; std::pair&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt; &gt; cv::dnn::getAvailableBackends",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getAvailableTargets()",
    "local": ""
  },
  {
    "origin": "std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::dnn::getAvailableTargets",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "be",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.getAvailableTargets(",
    "local": ""
  },
  {
    "origin": "be",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getLayerFactoryImpl()",
    "local": ""
  },
  {
    "origin": "&amp; cv::dnn::getLayerFactoryImpl",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "imagesFromBlob()",
    "local": ""
  },
  {
    "origin": "void cv::dnn::imagesFromBlob",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "blob_",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "images_",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "images_",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.imagesFromBlob(",
    "local": ""
  },
  {
    "origin": "blob_[, images_]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Parse a 4D blob and output the images it contains as 2D arrays through a simpler data structure (std::vector&lt;cv::Mat&gt;).",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "blob_",
    "local": ""
  },
  {
    "origin": "4 dimensional array (images, channels, height, width) in floating point precision (CV_32F) from which you would like to extract the images.",
    "local": ""
  },
  {
    "origin": "[out]",
    "local": ""
  },
  {
    "origin": "images_",
    "local": ""
  },
  {
    "origin": "array of 2D",
    "local": ""
  },
  {
    "origin": "containing the images extracted from the blob in floating point precision (CV_32F). They are non normalized neither mean added. The number of returned images equals the first dimension of the blob (batch size). Every image has a number of channels equals to the second dimension of the blob (depth).",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "NMSBoxes()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "void cv::dnn::NMSBoxes",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bboxes",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt; float &gt; &amp;",
    "local": ""
  },
  {
    "origin": "scores",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "score_threshold",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "nms_threshold",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "std::vector&lt; int &gt; &amp;",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "eta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const int",
    "local": ""
  },
  {
    "origin": "top_k",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.NMSBoxes(",
    "local": ""
  },
  {
    "origin": "bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.NMSBoxesRotated(",
    "local": ""
  },
  {
    "origin": "bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs non maximum suppression given boxes and corresponding scores.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bboxes",
    "local": ""
  },
  {
    "origin": "a set of bounding boxes to apply NMS.",
    "local": ""
  },
  {
    "origin": "scores",
    "local": ""
  },
  {
    "origin": "a set of corresponding confidences.",
    "local": ""
  },
  {
    "origin": "score_threshold",
    "local": ""
  },
  {
    "origin": "a threshold used to filter boxes by score.",
    "local": ""
  },
  {
    "origin": "nms_threshold",
    "local": ""
  },
  {
    "origin": "a threshold used in non maximum suppression.",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "the kept indices of bboxes after NMS.",
    "local": ""
  },
  {
    "origin": "eta",
    "local": ""
  },
  {
    "origin": "a coefficient in adaptive threshold formula: \\(nms\\_threshold_{i+1}=eta\\cdot nms\\_threshold_i\\).",
    "local": ""
  },
  {
    "origin": "top_k",
    "local": ""
  },
  {
    "origin": "if",
    "local": ""
  },
  {
    "origin": ", keep at most",
    "local": ""
  },
  {
    "origin": "picked indices.",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "NMSBoxes()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "void cv::dnn::NMSBoxes",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bboxes",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt; float &gt; &amp;",
    "local": ""
  },
  {
    "origin": "scores",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "score_threshold",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "nms_threshold",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "std::vector&lt; int &gt; &amp;",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "eta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const int",
    "local": ""
  },
  {
    "origin": "top_k",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.NMSBoxes(",
    "local": ""
  },
  {
    "origin": "bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.NMSBoxesRotated(",
    "local": ""
  },
  {
    "origin": "bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "NMSBoxes()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "void cv::dnn::NMSBoxes",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bboxes",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt; float &gt; &amp;",
    "local": ""
  },
  {
    "origin": "scores",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "score_threshold",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "nms_threshold",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "std::vector&lt; int &gt; &amp;",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const float",
    "local": ""
  },
  {
    "origin": "eta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const int",
    "local": ""
  },
  {
    "origin": "top_k",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.NMSBoxes(",
    "local": ""
  },
  {
    "origin": "bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "indices",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.NMSBoxesRotated(",
    "local": ""
  },
  {
    "origin": "bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNet()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNet",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "config",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "framework",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNet(",
    "local": ""
  },
  {
    "origin": "model[, config[, framework]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNet(",
    "local": ""
  },
  {
    "origin": "framework, bufferModel[, bufferConfig]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Read deep learning network represented in one of the supported formats.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": "Binary file contains trained weights. The following file extensions are expected for models from different frameworks:",
    "local": ""
  },
  {
    "origin": "(Caffe,",
    "local": ""
  },
  {
    "origin": "http://caffe.berkeleyvision.org/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(TensorFlow,",
    "local": ""
  },
  {
    "origin": "https://www.tensorflow.org/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(Torch,",
    "local": ""
  },
  {
    "origin": "http://torch.ch/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(Darknet,",
    "local": ""
  },
  {
    "origin": "https://pjreddie.com/darknet/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(DLDT,",
    "local": ""
  },
  {
    "origin": "https://software.intel.com/openvino-toolkit",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(ONNX,",
    "local": ""
  },
  {
    "origin": "https://onnx.ai/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "config",
    "local": ""
  },
  {
    "origin": "Text file contains network configuration. It could be a file with the following extensions:",
    "local": ""
  },
  {
    "origin": "(Caffe,",
    "local": ""
  },
  {
    "origin": "http://caffe.berkeleyvision.org/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(TensorFlow,",
    "local": ""
  },
  {
    "origin": "https://www.tensorflow.org/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(Darknet,",
    "local": ""
  },
  {
    "origin": "https://pjreddie.com/darknet/",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "(DLDT,",
    "local": ""
  },
  {
    "origin": "https://software.intel.com/openvino-toolkit",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "framework",
    "local": ""
  },
  {
    "origin": "Explicit framework name tag to determine a format.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "This function automatically detects an origin framework of trained model and calls an appropriate function such",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": ". An order of",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "arguments does not matter.",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNet()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNet",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "framework",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferConfig",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNet(",
    "local": ""
  },
  {
    "origin": "model[, config[, framework]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNet(",
    "local": ""
  },
  {
    "origin": "framework, bufferModel[, bufferConfig]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Read deep learning network represented in one of the supported formats.",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "framework",
    "local": ""
  },
  {
    "origin": "Name of origin framework.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "A buffer with a content of binary file with weights",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferConfig",
    "local": ""
  },
  {
    "origin": "A buffer with a content of text file contains network configuration.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromCaffe()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromCaffe",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "prototxt",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "caffeModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromCaffe(",
    "local": ""
  },
  {
    "origin": "prototxt[, caffeModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromCaffe(",
    "local": ""
  },
  {
    "origin": "bufferProto[, bufferModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Caffe",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "prototxt",
    "local": ""
  },
  {
    "origin": "path to the .prototxt file with text description of the network architecture.",
    "local": ""
  },
  {
    "origin": "caffeModel",
    "local": ""
  },
  {
    "origin": "path to the .caffemodel file with learned network.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromCaffe()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromCaffe",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferProto",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromCaffe(",
    "local": ""
  },
  {
    "origin": "prototxt[, caffeModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromCaffe(",
    "local": ""
  },
  {
    "origin": "bufferProto[, bufferModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in Caffe model in memory.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bufferProto",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the .prototxt file",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the .caffemodel file",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromCaffe()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromCaffe",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "bufferProto",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "lenProto",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "lenModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromCaffe(",
    "local": ""
  },
  {
    "origin": "prototxt[, caffeModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromCaffe(",
    "local": ""
  },
  {
    "origin": "bufferProto[, bufferModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in Caffe model in memory.",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bufferProto",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the .prototxt file",
    "local": ""
  },
  {
    "origin": "lenProto",
    "local": ""
  },
  {
    "origin": "length of bufferProto",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the .caffemodel file",
    "local": ""
  },
  {
    "origin": "lenModel",
    "local": ""
  },
  {
    "origin": "length of bufferModel",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromDarknet()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromDarknet",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "cfgFile",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "darknetModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromDarknet(",
    "local": ""
  },
  {
    "origin": "cfgFile[, darknetModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromDarknet(",
    "local": ""
  },
  {
    "origin": "bufferCfg[, bufferModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Darknet",
    "local": ""
  },
  {
    "origin": "model files.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "cfgFile",
    "local": ""
  },
  {
    "origin": "path to the .cfg file with text description of the network architecture.",
    "local": ""
  },
  {
    "origin": "darknetModel",
    "local": ""
  },
  {
    "origin": "path to the .weights file with learned network.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Network object that ready to do forward, throw an exception in failure cases.",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromDarknet()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromDarknet",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferCfg",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromDarknet(",
    "local": ""
  },
  {
    "origin": "cfgFile[, darknetModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromDarknet(",
    "local": ""
  },
  {
    "origin": "bufferCfg[, bufferModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Darknet",
    "local": ""
  },
  {
    "origin": "model files.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bufferCfg",
    "local": ""
  },
  {
    "origin": "A buffer contains a content of .cfg file with text description of the network architecture.",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "A buffer contains a content of .weights file with learned network.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromDarknet()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromDarknet",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "bufferCfg",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "lenCfg",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "lenModel",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromDarknet(",
    "local": ""
  },
  {
    "origin": "cfgFile[, darknetModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromDarknet(",
    "local": ""
  },
  {
    "origin": "bufferCfg[, bufferModel]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Darknet",
    "local": ""
  },
  {
    "origin": "model files.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bufferCfg",
    "local": ""
  },
  {
    "origin": "A buffer contains a content of .cfg file with text description of the network architecture.",
    "local": ""
  },
  {
    "origin": "lenCfg",
    "local": ""
  },
  {
    "origin": "Number of bytes to read from bufferCfg",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "A buffer contains a content of .weights file with learned network.",
    "local": ""
  },
  {
    "origin": "lenModel",
    "local": ""
  },
  {
    "origin": "Number of bytes to read from bufferModel",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromModelOptimizer()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromModelOptimizer",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "xml",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "bin",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromModelOptimizer(",
    "local": ""
  },
  {
    "origin": "xml, bin",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromModelOptimizer(",
    "local": ""
  },
  {
    "origin": "bufferModelConfig, bufferWeights",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Load a network from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer intermediate representation.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "xml",
    "local": ""
  },
  {
    "origin": "XML configuration file with network's topology.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bin",
    "local": ""
  },
  {
    "origin": "Binary file with trained weights.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object. Networks imported from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer are launched in Intel's Inference Engine backend.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromModelOptimizer()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromModelOptimizer",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferModelConfig",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferWeights",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromModelOptimizer(",
    "local": ""
  },
  {
    "origin": "xml, bin",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromModelOptimizer(",
    "local": ""
  },
  {
    "origin": "bufferModelConfig, bufferWeights",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Load a network from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer intermediate representation.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferModelConfig",
    "local": ""
  },
  {
    "origin": "Buffer contains XML configuration with network's topology.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferWeights",
    "local": ""
  },
  {
    "origin": "Buffer contains binary data with trained weights.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object. Networks imported from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer are launched in Intel's Inference Engine backend.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromModelOptimizer()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromModelOptimizer",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "*",
    "local": ""
  },
  {
    "origin": "bufferModelConfigPtr",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "bufferModelConfigSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "*",
    "local": ""
  },
  {
    "origin": "bufferWeightsPtr",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "bufferWeightsSize",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromModelOptimizer(",
    "local": ""
  },
  {
    "origin": "xml, bin",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromModelOptimizer(",
    "local": ""
  },
  {
    "origin": "bufferModelConfig, bufferWeights",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Load a network from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer intermediate representation.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferModelConfigPtr",
    "local": ""
  },
  {
    "origin": "Pointer to buffer which contains XML configuration with network's topology.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferModelConfigSize",
    "local": ""
  },
  {
    "origin": "Binary size of XML configuration data.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferWeightsPtr",
    "local": ""
  },
  {
    "origin": "Pointer to buffer which contains binary data with trained weights.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "bufferWeightsSize",
    "local": ""
  },
  {
    "origin": "Binary size of trained weights data.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object. Networks imported from Intel's",
    "local": ""
  },
  {
    "origin": "Optimizer are launched in Intel's Inference Engine backend.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromONNX()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromONNX",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "onnxFile",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromONNX(",
    "local": ""
  },
  {
    "origin": "onnxFile",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromONNX(",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model",
    "local": ""
  },
  {
    "origin": "ONNX",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "onnxFile",
    "local": ""
  },
  {
    "origin": "path to the .onnx file with text description of the network architecture.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Network object that ready to do forward, throw an exception in failure cases.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromONNX()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromONNX",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "sizeBuffer",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromONNX(",
    "local": ""
  },
  {
    "origin": "onnxFile",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromONNX(",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model from",
    "local": ""
  },
  {
    "origin": "ONNX",
    "local": ""
  },
  {
    "origin": "in-memory buffer.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": "memory address of the first byte of the buffer.",
    "local": ""
  },
  {
    "origin": "sizeBuffer",
    "local": ""
  },
  {
    "origin": "size of the buffer.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Network object that ready to do forward, throw an exception in failure cases.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromONNX()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromONNX",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromONNX(",
    "local": ""
  },
  {
    "origin": "onnxFile",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromONNX(",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model from",
    "local": ""
  },
  {
    "origin": "ONNX",
    "local": ""
  },
  {
    "origin": "in-memory buffer.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "buffer",
    "local": ""
  },
  {
    "origin": "in-memory buffer that stores the ONNX model bytes.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Network object that ready to do forward, throw an exception in failure cases.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromTensorflow()",
    "local": ""
  },
  {
    "origin": "[1/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromTensorflow",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "config",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTensorflow(",
    "local": ""
  },
  {
    "origin": "model[, config]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTensorflow(",
    "local": ""
  },
  {
    "origin": "bufferModel[, bufferConfig]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "TensorFlow",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": "path to the .pb file with binary protobuf description of the network architecture",
    "local": ""
  },
  {
    "origin": "config",
    "local": ""
  },
  {
    "origin": "path to the .pbtxt file that contains text graph definition in protobuf format. Resulting",
    "local": ""
  },
  {
    "origin": "object is built by text graph using weights from a binary one that let us make it more flexible.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromTensorflow()",
    "local": ""
  },
  {
    "origin": "[2/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromTensorflow",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "bufferConfig",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTensorflow(",
    "local": ""
  },
  {
    "origin": "model[, config]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTensorflow(",
    "local": ""
  },
  {
    "origin": "bufferModel[, bufferConfig]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "TensorFlow",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the pb file",
    "local": ""
  },
  {
    "origin": "bufferConfig",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the pbtxt file",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromTensorflow()",
    "local": ""
  },
  {
    "origin": "[3/3]",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromTensorflow",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "lenModel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const char *",
    "local": ""
  },
  {
    "origin": "bufferConfig",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "size_t",
    "local": ""
  },
  {
    "origin": "lenConfig",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTensorflow(",
    "local": ""
  },
  {
    "origin": "model[, config]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTensorflow(",
    "local": ""
  },
  {
    "origin": "bufferModel[, bufferConfig]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "TensorFlow",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "bufferModel",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the pb file",
    "local": ""
  },
  {
    "origin": "lenModel",
    "local": ""
  },
  {
    "origin": "length of bufferModel",
    "local": ""
  },
  {
    "origin": "bufferConfig",
    "local": ""
  },
  {
    "origin": "buffer containing the content of the pbtxt file",
    "local": ""
  },
  {
    "origin": "lenConfig",
    "local": ""
  },
  {
    "origin": "length of bufferConfig",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readNetFromTorch()",
    "local": ""
  },
  {
    "origin": "cv::dnn::readNetFromTorch",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "isBinary",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "evaluate",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readNetFromTorch(",
    "local": ""
  },
  {
    "origin": "model[, isBinary[, evaluate]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Reads a network model stored in",
    "local": ""
  },
  {
    "origin": "Torch7",
    "local": ""
  },
  {
    "origin": "framework's format.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": "path to the file, dumped from Torch by using torch.save() function.",
    "local": ""
  },
  {
    "origin": "isBinary",
    "local": ""
  },
  {
    "origin": "specifies whether the network was serialized in ascii mode or binary.",
    "local": ""
  },
  {
    "origin": "evaluate",
    "local": ""
  },
  {
    "origin": "specifies testing phase of network. If true, it's similar to evaluate() method in Torch.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "object.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Ascii mode of Torch serializer is more preferable, because binary mode extensively use",
    "local": ""
  },
  {
    "origin": "type of C language, which has various bit-length on different systems.",
    "local": ""
  },
  {
    "origin": "The loading file must contain serialized",
    "local": ""
  },
  {
    "origin": "nn.Module",
    "local": ""
  },
  {
    "origin": "object with importing network. Try to eliminate a custom objects from serialazing data to avoid importing errors.",
    "local": ""
  },
  {
    "origin": "List of supported layers (i.e. object instances derived from Torch nn.Module class):",
    "local": ""
  },
  {
    "origin": "nn.Sequential",
    "local": ""
  },
  {
    "origin": "nn.Parallel",
    "local": ""
  },
  {
    "origin": "nn.Concat",
    "local": ""
  },
  {
    "origin": "nn.Linear",
    "local": ""
  },
  {
    "origin": "nn.SpatialConvolution",
    "local": ""
  },
  {
    "origin": "nn.SpatialMaxPooling, nn.SpatialAveragePooling",
    "local": ""
  },
  {
    "origin": "nn.ReLU, nn.TanH, nn.Sigmoid",
    "local": ""
  },
  {
    "origin": "nn.Reshape",
    "local": ""
  },
  {
    "origin": "nn.SoftMax, nn.LogSoftMax",
    "local": ""
  },
  {
    "origin": "Also some equivalents of these classes from cunn, cudnn, and fbcunn may be successfully imported.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readTensorFromONNX()",
    "local": ""
  },
  {
    "origin": "cv::dnn::readTensorFromONNX",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "path",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readTensorFromONNX(",
    "local": ""
  },
  {
    "origin": "path",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates blob from .pb file.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "path",
    "local": ""
  },
  {
    "origin": "to the .pb file with input tensor.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "readTorchBlob()",
    "local": ""
  },
  {
    "origin": "cv::dnn::readTorchBlob",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "filename",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "isBinary",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.readTorchBlob(",
    "local": ""
  },
  {
    "origin": "filename[, isBinary]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Loads blob which was serialized as torch.Tensor object of Torch7 framework.",
    "local": ""
  },
  {
    "origin": "Warning",
    "local": ""
  },
  {
    "origin": "This function has the same limitations as",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "shrinkCaffeModel()",
    "local": ""
  },
  {
    "origin": "void cv::dnn::shrinkCaffeModel",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "layersTypes",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.shrinkCaffeModel(",
    "local": ""
  },
  {
    "origin": "src, dst[, layersTypes]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Convert all weights of Caffe network to half precision floating point.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Path to origin model from Caffe framework contains single precision floating point weights (usually has",
    "local": ""
  },
  {
    "origin": "extension).",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Path to destination model with updated weights.",
    "local": ""
  },
  {
    "origin": "layersTypes",
    "local": ""
  },
  {
    "origin": "Set of layers types which parameters will be converted. By default, converts only Convolutional and Fully-Connected layers' weights.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Shrinked model has no origin float32 weights so it can't be used in origin Caffe framework anymore. However the structure of data is taken from NVidia's Caffe fork:",
    "local": ""
  },
  {
    "origin": "https://github.com/NVIDIA/caffe",
    "local": ""
  },
  {
    "origin": ". So the resulting model may be used there.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "writeTextGraph()",
    "local": ""
  },
  {
    "origin": "void cv::dnn::writeTextGraph",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "output",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.dnn.writeTextGraph(",
    "local": ""
  },
  {
    "origin": "model, output",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Create a text representation for a binary network stored in protocol buffer format.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "model",
    "local": ""
  },
  {
    "origin": "A path to binary network.",
    "local": ""
  },
  {
    "origin": "[in]",
    "local": ""
  },
  {
    "origin": "output",
    "local": ""
  },
  {
    "origin": "A path to output text file to be created.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "To reduce output file size, trained weights are not included.",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:41 for OpenCV by",
    "local": ""
  }
]