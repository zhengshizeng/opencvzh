[
  {
    "origin": "OpenCV: Graph API: Image filters",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "Graph API: Image filters",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int d, double sigmaColor, double sigmaSpace, int borderType=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies the bilateral filter to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;ksize, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor=",
    "local": ""
  },
  {
    "origin": "(-1,-1), int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Blurs an image using the normalized box filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int dtype, const",
    "local": ""
  },
  {
    "origin": "&amp;ksize, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor=",
    "local": ""
  },
  {
    "origin": "(-1,-1), bool",
    "local": ""
  },
  {
    "origin": "=true, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Blurs an image using the box filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;kernel, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor=",
    "local": ""
  },
  {
    "origin": "(-1,-1), int iterations=1, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Dilates an image by using a specific structuring element.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int iterations=1, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Dilates an image by using 3 by 3 rectangular structuring element.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;kernel, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor=",
    "local": ""
  },
  {
    "origin": "(-1,-1), int iterations=1, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Erodes an image by using a specific structuring element.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int iterations=1, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Erodes an image by using 3 by 3 rectangular structuring element.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int ddepth, const",
    "local": ""
  },
  {
    "origin": "&amp;kernel, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor=",
    "local": ""
  },
  {
    "origin": "(-1,-1), const",
    "local": ""
  },
  {
    "origin": "&amp;delta=",
    "local": ""
  },
  {
    "origin": "(0), int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Convolves an image with the kernel.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "&amp;ksize, double sigmaX, double sigmaY=0, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Blurs an image using a Gaussian filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int ddepth, int ksize=1, double scale=1, double delta=0, int borderType=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates the Laplacian of an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int ksize)",
    "local": ""
  },
  {
    "origin": "Blurs an image using the median filter.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, const",
    "local": ""
  },
  {
    "origin": "op, const",
    "local": ""
  },
  {
    "origin": "&amp;kernel, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor=",
    "local": ""
  },
  {
    "origin": "(-1,-1), const int iterations=1, const",
    "local": ""
  },
  {
    "origin": "borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Performs advanced morphological transformations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int ddepth, const",
    "local": ""
  },
  {
    "origin": "&amp;kernelX, const",
    "local": ""
  },
  {
    "origin": "&amp;kernelY, const",
    "local": ""
  },
  {
    "origin": "&amp;anchor, const",
    "local": ""
  },
  {
    "origin": "&amp;delta, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Applies a separable linear filter to a matrix(image).",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "std::tuple&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;src, int ddepth, int order, int ksize=3, double scale=1, double delta=0, int borderType=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "(0))",
    "local": ""
  },
  {
    "origin": "Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "bilateralFilter()",
    "local": ""
  },
  {
    "origin": "cv::gapi::bilateralFilter",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "d",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "sigmaColor",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "sigmaSpace",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies the bilateral filter to an image.",
    "local": ""
  },
  {
    "origin": "The function applies bilateral filtering to the input image, as described in",
    "local": ""
  },
  {
    "origin": "http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html",
    "local": ""
  },
  {
    "origin": "bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.",
    "local": ""
  },
  {
    "origin": "Sigma values",
    "local": ""
  },
  {
    "origin": ": For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt; 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very strong effect, making the image look \"cartoonish\".",
    "local": ""
  },
  {
    "origin": "Filter size",
    "local": ""
  },
  {
    "origin": ": Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.",
    "local": ""
  },
  {
    "origin": "This filter does not work inplace.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.bilateralfilter\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source 8-bit or floating-point, 1-channel or 3-channel image.",
    "local": ""
  },
  {
    "origin": "d",
    "local": ""
  },
  {
    "origin": "Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace.",
    "local": ""
  },
  {
    "origin": "sigmaColor",
    "local": ""
  },
  {
    "origin": "Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color.",
    "local": ""
  },
  {
    "origin": "sigmaSpace",
    "local": ""
  },
  {
    "origin": "Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "border mode used to extrapolate pixels outside of the image, see",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Destination image of the same size and type as src.",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "blur()",
    "local": ""
  },
  {
    "origin": "cv::gapi::blur",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Blurs an image using the normalized box filter.",
    "local": ""
  },
  {
    "origin": "The function smooths an image using the kernel:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{K} = \\frac{1}{\\texttt{ksize.width*ksize.height}} \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\hdotsfor{6} \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\end{bmatrix}\\]",
    "local": ""
  },
  {
    "origin": "The call",
    "local": ""
  },
  {
    "origin": "is equivalent to",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.blur\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "blurring kernel size.",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "border mode used to extrapolate pixels outside of the image, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "boxFilter()",
    "local": ""
  },
  {
    "origin": "cv::gapi::boxFilter",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dtype",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "normalize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Blurs an image using the box filter.",
    "local": ""
  },
  {
    "origin": "The function smooths an image using the kernel:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{K} = \\alpha \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\\\ \\hdotsfor{6} \\\\ 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1 \\end{bmatrix}\\]",
    "local": ""
  },
  {
    "origin": "where",
    "local": ""
  },
  {
    "origin": "\\[\\alpha = \\begin{cases} \\frac{1}{\\texttt{ksize.width*ksize.height}} &amp; \\texttt{when } \\texttt{normalize=true} \\\\1 &amp; \\texttt{otherwise} \\end{cases}\\]",
    "local": ""
  },
  {
    "origin": "Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.boxfilter\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "dtype",
    "local": ""
  },
  {
    "origin": "the output image depth (-1 to set the input image data type).",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "blurring kernel size.",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "Anchor position within the kernel. The default value \\((-1,-1)\\) means that the anchor is at the kernel center.",
    "local": ""
  },
  {
    "origin": "normalize",
    "local": ""
  },
  {
    "origin": "flag, specifying whether the kernel is normalized by its area or not.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "Pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "dilate()",
    "local": ""
  },
  {
    "origin": "cv::gapi::dilate",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Dilates an image by using a specific structuring element.",
    "local": ""
  },
  {
    "origin": "The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\max _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\]",
    "local": ""
  },
  {
    "origin": "Dilation can be applied several (iterations) times. In case of multi-channel images, each channel is processed independently. Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.dilate\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": "structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using getStructuringElement",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "number of times dilation is applied.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of a constant border",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "dilate3x3()",
    "local": ""
  },
  {
    "origin": "cv::gapi::dilate3x3",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Dilates an image by using 3 by 3 rectangular structuring element.",
    "local": ""
  },
  {
    "origin": "The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\max _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\]",
    "local": ""
  },
  {
    "origin": "Dilation can be applied several (iterations) times. In case of multi-channel images, each channel is processed independently. Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.dilate\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "number of times dilation is applied.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of a constant border",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "erode()",
    "local": ""
  },
  {
    "origin": "cv::gapi::erode",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Erodes an image by using a specific structuring element.",
    "local": ""
  },
  {
    "origin": "The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\min _{(x',y'): \\, \\texttt{element} (x',y') \\ne0 } \\texttt{src} (x+x',y+y')\\]",
    "local": ""
  },
  {
    "origin": "Erosion can be applied several (iterations) times. In case of multi-channel images, each channel is processed independently. Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.erode\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": "structuring element used for erosion; if",
    "local": ""
  },
  {
    "origin": ", a",
    "local": ""
  },
  {
    "origin": "rectangular structuring element is used. Kernel can be created using getStructuringElement.",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "number of times erosion is applied.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of a constant border",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "erode3x3()",
    "local": ""
  },
  {
    "origin": "cv::gapi::erode3x3",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Erodes an image by using 3 by 3 rectangular structuring element.",
    "local": ""
  },
  {
    "origin": "The function erodes the source image using the rectangular structuring element with rectangle center as an anchor. Erosion can be applied several (iterations) times. In case of multi-channel images, each channel is processed independently. Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.erode\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "number of times erosion is applied.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of a constant border",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "filter2D()",
    "local": ""
  },
  {
    "origin": "cv::gapi::filter2D",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Convolves an image with the kernel.",
    "local": ""
  },
  {
    "origin": "The function applies an arbitrary linear filter to an image. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.",
    "local": ""
  },
  {
    "origin": "The function does actually compute correlation, not the convolution:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\sum _{ \\substack{0\\leq x' &lt; \\texttt{kernel.cols}\\\\{0\\leq y' &lt; \\texttt{kernel.rows}}}} \\texttt{kernel} (x',y')* \\texttt{src} (x+x'- \\texttt{anchor.x} ,y+y'- \\texttt{anchor.y} )\\]",
    "local": ""
  },
  {
    "origin": "That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using flip and set the new anchor to",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Supported matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ". Output image must have the same size and number of channels an input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.filter2D\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "desired depth of the destination image",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": "convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually.",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "optional value added to the filtered pixels before storing them in dst.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "gaussianBlur()",
    "local": ""
  },
  {
    "origin": "cv::gapi::gaussianBlur",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "sigmaX",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "sigmaY",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Blurs an image using a Gaussian filter.",
    "local": ""
  },
  {
    "origin": "The function filter2Ds the source image with the specified Gaussian kernel. Output image must have the same type and number of channels an input image.",
    "local": ""
  },
  {
    "origin": "Supported input matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.gaussianBlur\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image;",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma.",
    "local": ""
  },
  {
    "origin": "sigmaX",
    "local": ""
  },
  {
    "origin": "Gaussian kernel standard deviation in X direction.",
    "local": ""
  },
  {
    "origin": "sigmaY",
    "local": ""
  },
  {
    "origin": "Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see",
    "local": ""
  },
  {
    "origin": "for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "Laplacian()",
    "local": ""
  },
  {
    "origin": "cv::gapi::Laplacian",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates the Laplacian of an image.",
    "local": ""
  },
  {
    "origin": "The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} = \\Delta \\texttt{src} = \\frac{\\partial^2 \\texttt{src}}{\\partial x^2} + \\frac{\\partial^2 \\texttt{src}}{\\partial y^2}\\]",
    "local": ""
  },
  {
    "origin": "This is done when",
    "local": ""
  },
  {
    "origin": ". When",
    "local": ""
  },
  {
    "origin": ", the Laplacian is computed by filtering the image with the following \\(3 \\times 3\\) aperture:",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\\]",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.laplacian\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "Desired depth of the destination image.",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "Aperture size used to compute the second-derivative filters. See",
    "local": ""
  },
  {
    "origin": "for details. The size must be positive and odd.",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See",
    "local": ""
  },
  {
    "origin": "for details.",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "Optional delta value that is added to the results prior to storing them in dst .",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "Pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "is not supported.",
    "local": ""
  },
  {
    "origin": "Returns",
    "local": ""
  },
  {
    "origin": "Destination image of the same size and the same number of channels as src.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "medianBlur()",
    "local": ""
  },
  {
    "origin": "cv::gapi::medianBlur",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.gapi.medianBlur(",
    "local": ""
  },
  {
    "origin": "src, ksize",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Blurs an image using the median filter.",
    "local": ""
  },
  {
    "origin": "The function smoothes an image using the median filter with the \\(\\texttt{ksize} \\times \\texttt{ksize}\\) aperture. Each channel of a multi-channel image is processed independently. Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest. The median filter uses",
    "local": ""
  },
  {
    "origin": "internally to cope with border pixels, see",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.medianBlur\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input matrix (image)",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "morphologyEx()",
    "local": ""
  },
  {
    "origin": "cv::gapi::morphologyEx",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "op",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const int",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Performs advanced morphological transformations.",
    "local": ""
  },
  {
    "origin": "The function can perform advanced morphological transformations using an erosion and dilation as basic operations.",
    "local": ""
  },
  {
    "origin": "Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.morphologyEx\"",
    "local": ""
  },
  {
    "origin": "The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (",
    "local": ""
  },
  {
    "origin": ") with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Input image.",
    "local": ""
  },
  {
    "origin": "op",
    "local": ""
  },
  {
    "origin": "Type of a morphological operation, see",
    "local": ""
  },
  {
    "origin": "kernel",
    "local": ""
  },
  {
    "origin": "Structuring element. It can be created using",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "Anchor position within the element. Both negative values mean that the anchor is at the kernel center.",
    "local": ""
  },
  {
    "origin": "iterations",
    "local": ""
  },
  {
    "origin": "Number of times erosion and dilation are applied.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "Pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "is not supported.",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "Border value in case of a constant border. The default value has a special meaning.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "sepFilter()",
    "local": ""
  },
  {
    "origin": "cv::gapi::sepFilter",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "kernelX",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "kernelY",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies a separable linear filter to a matrix(image).",
    "local": ""
  },
  {
    "origin": "The function applies a separable linear filter to the matrix. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result is returned.",
    "local": ""
  },
  {
    "origin": "Supported matrix data types are",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ". Output image must have the same type, size, and number of channels as the input image.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "In case of floating-point computation, rounding to nearest even is procedeed if hardware supports it (if not - to nearest value).",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.sepfilter\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "desired depth of the destination image (the following combinations of",
    "local": ""
  },
  {
    "origin": "and ddepth are supported:",
    "local": ""
  },
  {
    "origin": "src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F src.depth() = CV_64F, ddepth = -1/CV_64F",
    "local": ""
  },
  {
    "origin": "when ddepth=-1, the output image will have the same depth as the source)",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "kernelX",
    "local": ""
  },
  {
    "origin": "Coefficients for filtering each row.",
    "local": ""
  },
  {
    "origin": "kernelY",
    "local": ""
  },
  {
    "origin": "Coefficients for filtering each column.",
    "local": ""
  },
  {
    "origin": "anchor",
    "local": ""
  },
  {
    "origin": "Anchor position within the kernel. The default value \\((-1,-1)\\) means that the anchor is at the kernel center.",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "Value added to the filtered results before storing them.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "Pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "Sobel()",
    "local": ""
  },
  {
    "origin": "cv::gapi::Sobel",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dx",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dy",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.",
    "local": ""
  },
  {
    "origin": "In all cases except one, the \\(\\texttt{ksize} \\times \\texttt{ksize}\\) separable kernel is used to calculate the derivative. When \\(\\texttt{ksize = 1}\\), the \\(3 \\times 1\\) or \\(1 \\times 3\\) kernel is used (that is, no Gaussian smoothing is done).",
    "local": ""
  },
  {
    "origin": "can only be used for the first or the second x- or y- derivatives.",
    "local": ""
  },
  {
    "origin": "There is also the special value",
    "local": ""
  },
  {
    "origin": "that corresponds to the \\(3\\times3\\) Scharr filter that may give more accurate results than the \\(3\\times3\\) Sobel. The Scharr aperture is",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\]",
    "local": ""
  },
  {
    "origin": "for the x-derivative, or transposed for the y-derivative.",
    "local": ""
  },
  {
    "origin": "The function calculates an image derivative by convolving the image with the appropriate kernel:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} = \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\]",
    "local": ""
  },
  {
    "origin": "The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\]",
    "local": ""
  },
  {
    "origin": "The second case corresponds to a kernel of:",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\]",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.sobel\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "output image depth, see",
    "local": ""
  },
  {
    "origin": "; in the case of 8-bit input images it will result in truncated derivatives.",
    "local": ""
  },
  {
    "origin": "dx",
    "local": ""
  },
  {
    "origin": "order of the derivative x.",
    "local": ""
  },
  {
    "origin": "dy",
    "local": ""
  },
  {
    "origin": "order of the derivative y.",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "size of the extended Sobel kernel; it must be odd.",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "optional scale factor for the computed derivative values; by default, no scaling is applied (see",
    "local": ""
  },
  {
    "origin": "for details).",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "optional delta value that is added to the results prior to storing them in dst.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "â—†",
    "local": ""
  },
  {
    "origin": "SobelXY()",
    "local": ""
  },
  {
    "origin": "std::tuple&lt;",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "&gt; cv::gapi::SobelXY",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "order",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.",
    "local": ""
  },
  {
    "origin": "In all cases except one, the \\(\\texttt{ksize} \\times \\texttt{ksize}\\) separable kernel is used to calculate the derivative. When \\(\\texttt{ksize = 1}\\), the \\(3 \\times 1\\) or \\(1 \\times 3\\) kernel is used (that is, no Gaussian smoothing is done).",
    "local": ""
  },
  {
    "origin": "can only be used for the first or the second x- or y- derivatives.",
    "local": ""
  },
  {
    "origin": "There is also the special value",
    "local": ""
  },
  {
    "origin": "that corresponds to the \\(3\\times3\\) Scharr filter that may give more accurate results than the \\(3\\times3\\) Sobel. The Scharr aperture is",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\\]",
    "local": ""
  },
  {
    "origin": "for the x-derivative, or transposed for the y-derivative.",
    "local": ""
  },
  {
    "origin": "The function calculates an image derivative by convolving the image with the appropriate kernel:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} = \\frac{\\partial^{xorder+yorder} \\texttt{src}}{\\partial x^{xorder} \\partial y^{yorder}}\\]",
    "local": ""
  },
  {
    "origin": "The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\\]",
    "local": ""
  },
  {
    "origin": "The second case corresponds to a kernel of:",
    "local": ""
  },
  {
    "origin": "\\[\\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\\]",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "First returned matrix correspons to dx derivative while the second one to dy.",
    "local": ""
  },
  {
    "origin": "Rounding to nearest even is procedeed if hardware supports it, if not - to nearest.",
    "local": ""
  },
  {
    "origin": "Function textual ID is \"org.opencv.imgproc.filters.sobelxy\"",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "ddepth",
    "local": ""
  },
  {
    "origin": "output image depth, see",
    "local": ""
  },
  {
    "origin": "; in the case of 8-bit input images it will result in truncated derivatives.",
    "local": ""
  },
  {
    "origin": "order",
    "local": ""
  },
  {
    "origin": "order of the derivatives.",
    "local": ""
  },
  {
    "origin": "ksize",
    "local": ""
  },
  {
    "origin": "size of the extended Sobel kernel; it must be odd.",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "optional scale factor for the computed derivative values; by default, no scaling is applied (see",
    "local": ""
  },
  {
    "origin": "for details).",
    "local": ""
  },
  {
    "origin": "delta",
    "local": ""
  },
  {
    "origin": "optional delta value that is added to the results prior to storing them in dst.",
    "local": ""
  },
  {
    "origin": "borderType",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method, see",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "border value in case of constant border type",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:41 for OpenCV by",
    "local": ""
  }
]