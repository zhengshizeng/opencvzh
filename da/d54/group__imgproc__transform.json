[
  {
    "origin": "OpenCV: Geometric Image Transformations",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "Geometric Image Transformations",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "= 16",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "interpolation algorithm",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "= 1 &lt;&lt; INTER_BITS,",
    "local": ""
  },
  {
    "origin": "= INTER_TAB_SIZE * INTER_TAB_SIZE",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Specify the polar mapping mode.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "map1,",
    "local": ""
  },
  {
    "origin": "map2,",
    "local": ""
  },
  {
    "origin": "dstmap1,",
    "local": ""
  },
  {
    "origin": "dstmap2, int dstmap1type, bool nninterpolation=false)",
    "local": ""
  },
  {
    "origin": "Converts image transformation maps from one representation to another.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "src[], const",
    "local": ""
  },
  {
    "origin": "dst[])",
    "local": ""
  },
  {
    "origin": "Calculates an affine transform from three pairs of the corresponding points.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst)",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, int solveMethod=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates a perspective transform from four pairs of the corresponding points.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "src[], const",
    "local": ""
  },
  {
    "origin": "dst[], int solveMethod=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image,",
    "local": ""
  },
  {
    "origin": "patchSize,",
    "local": ""
  },
  {
    "origin": "center,",
    "local": ""
  },
  {
    "origin": "patch, int patchType=-1)",
    "local": ""
  },
  {
    "origin": "Retrieves a pixel rectangle from an image with sub-pixel accuracy.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "center, double angle, double scale)",
    "local": ""
  },
  {
    "origin": "Calculates an affine matrix of 2D rotation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "center, double angle, double scale)",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "M,",
    "local": ""
  },
  {
    "origin": "iM)",
    "local": ""
  },
  {
    "origin": "Inverts an affine transformation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "center, double maxRadius, int flags)",
    "local": ""
  },
  {
    "origin": "Remaps an image to polar coordinates space.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "center, double M, int flags)",
    "local": ""
  },
  {
    "origin": "Remaps an image to semilog-polar coordinates space.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "map1,",
    "local": ""
  },
  {
    "origin": "map2, int interpolation, int borderMode=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies a generic geometrical transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "dsize, double fx=0, double fy=0, int interpolation=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "M,",
    "local": ""
  },
  {
    "origin": "dsize, int flags=",
    "local": ""
  },
  {
    "origin": ", int borderMode=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies an affine transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "M,",
    "local": ""
  },
  {
    "origin": "dsize, int flags=",
    "local": ""
  },
  {
    "origin": ", int borderMode=",
    "local": ""
  },
  {
    "origin": ", const",
    "local": ""
  },
  {
    "origin": "&amp;borderValue=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Applies a perspective transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst,",
    "local": ""
  },
  {
    "origin": "dsize,",
    "local": ""
  },
  {
    "origin": "center, double maxRadius, int flags)",
    "local": ""
  },
  {
    "origin": "Remaps an image to polar or semilog-polar coordinates space.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "The functions in this section perform various geometrical transformations of 2D images. They do not change the image content but deform the pixel grid and map this deformed grid to the destination image. In fact, to avoid sampling artifacts, the mapping is done in the reverse order, from destination to the source. That is, for each pixel \\((x, y)\\) of the destination image, the functions compute coordinates of the corresponding \"donor\" pixel in the source image and copy the pixel value:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y)= \\texttt{src} (f_x(x,y), f_y(x,y))\\]",
    "local": ""
  },
  {
    "origin": "In case when you specify the forward mapping \\(\\left&lt;g_x, g_y\\right&gt;: \\texttt{src} \\rightarrow \\texttt{dst}\\), the OpenCV functions first compute the corresponding inverse mapping \\(\\left&lt;f_x, f_y\\right&gt;: \\texttt{dst} \\rightarrow \\texttt{src}\\) and then use the above formula.",
    "local": ""
  },
  {
    "origin": "The actual implementations of the geometrical transformations, from the most generic remap and to the simplest and the fastest resize, need to solve two main problems with the above formula:",
    "local": ""
  },
  {
    "origin": "Extrapolation of non-existing pixels. Similarly to the filtering functions described in the previous section, for some \\((x,y)\\), either one of \\(f_x(x,y)\\), or \\(f_y(x,y)\\), or both of them may fall outside of the image. In this case, an extrapolation method needs to be used. OpenCV provides the same selection of extrapolation methods as in the filtering functions. In addition, it provides the method",
    "local": ""
  },
  {
    "origin": ". This means that the corresponding pixels in the destination image will not be modified at all.",
    "local": ""
  },
  {
    "origin": "Interpolation of pixel values. Usually \\(f_x(x,y)\\) and \\(f_y(x,y)\\) are floating-point numbers. This means that \\(\\left&lt;f_x, f_y\\right&gt;\\) can be either an affine or perspective transformation, or radial lens distortion correction, and so on. So, a pixel value at fractional coordinates needs to be retrieved. In the simplest case, the coordinates can be just rounded to the nearest integer coordinates and the corresponding pixel can be used. This is called a nearest-neighbor interpolation. However, a better result can be achieved by using more sophisticated",
    "local": ""
  },
  {
    "origin": "interpolation methods",
    "local": ""
  },
  {
    "origin": ", where a polynomial function is fit into some neighborhood of the computed pixel \\((f_x(x,y), f_y(x,y))\\), and then the value of the polynomial at \\((f_x(x,y), f_y(x,y))\\) is taken as the interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See resize for details.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "The geometrical transformations do not work with",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": "images.",
    "local": ""
  },
  {
    "origin": "Enumeration Type Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "InterpolationFlags",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "interpolation algorithm",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "INTER_NEAREST",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_NEAREST",
    "local": ""
  },
  {
    "origin": "nearest neighbor interpolation",
    "local": ""
  },
  {
    "origin": "INTER_LINEAR",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_LINEAR",
    "local": ""
  },
  {
    "origin": "bilinear interpolation",
    "local": ""
  },
  {
    "origin": "INTER_CUBIC",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_CUBIC",
    "local": ""
  },
  {
    "origin": "bicubic interpolation",
    "local": ""
  },
  {
    "origin": "INTER_AREA",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_AREA",
    "local": ""
  },
  {
    "origin": "resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire'-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.",
    "local": ""
  },
  {
    "origin": "INTER_LANCZOS4",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_LANCZOS4",
    "local": ""
  },
  {
    "origin": "Lanczos interpolation over 8x8 neighborhood",
    "local": ""
  },
  {
    "origin": "INTER_LINEAR_EXACT",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_LINEAR_EXACT",
    "local": ""
  },
  {
    "origin": "Bit exact bilinear interpolation",
    "local": ""
  },
  {
    "origin": "INTER_NEAREST_EXACT",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_NEAREST_EXACT",
    "local": ""
  },
  {
    "origin": "Bit exact nearest neighbor interpolation. This will produce same results as the nearest neighbor method in PIL, scikit-image or Matlab.",
    "local": ""
  },
  {
    "origin": "INTER_MAX",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_MAX",
    "local": ""
  },
  {
    "origin": "mask for interpolation codes",
    "local": ""
  },
  {
    "origin": "WARP_FILL_OUTLIERS",
    "local": ""
  },
  {
    "origin": "Python: cv.WARP_FILL_OUTLIERS",
    "local": ""
  },
  {
    "origin": "flag, fills all of the destination image pixels. If some of them correspond to outliers in the source image, they are set to zero",
    "local": ""
  },
  {
    "origin": "WARP_INVERSE_MAP",
    "local": ""
  },
  {
    "origin": "Python: cv.WARP_INVERSE_MAP",
    "local": ""
  },
  {
    "origin": "flag, inverse transformation",
    "local": ""
  },
  {
    "origin": "For example,",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": "transforms:",
    "local": ""
  },
  {
    "origin": "flag is",
    "local": ""
  },
  {
    "origin": "not",
    "local": ""
  },
  {
    "origin": "set: \\(dst( \\rho , \\phi ) = src(x,y)\\)",
    "local": ""
  },
  {
    "origin": "flag is set: \\(dst(x,y) = src( \\rho , \\phi )\\)",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "InterpolationMasks",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "INTER_BITS",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_BITS",
    "local": ""
  },
  {
    "origin": "INTER_BITS2",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_BITS2",
    "local": ""
  },
  {
    "origin": "INTER_TAB_SIZE",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_TAB_SIZE",
    "local": ""
  },
  {
    "origin": "INTER_TAB_SIZE2",
    "local": ""
  },
  {
    "origin": "Python: cv.INTER_TAB_SIZE2",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "WarpPolarMode",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Specify the polar mapping mode.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "WARP_POLAR_LINEAR",
    "local": ""
  },
  {
    "origin": "Python: cv.WARP_POLAR_LINEAR",
    "local": ""
  },
  {
    "origin": "Remaps an image to/from polar space.",
    "local": ""
  },
  {
    "origin": "WARP_POLAR_LOG",
    "local": ""
  },
  {
    "origin": "Python: cv.WARP_POLAR_LOG",
    "local": ""
  },
  {
    "origin": "Remaps an image to/from semilog-polar space.",
    "local": ""
  },
  {
    "origin": "Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "convertMaps()",
    "local": ""
  },
  {
    "origin": "void cv::convertMaps",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "map1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "map2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dstmap1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dstmap2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "dstmap1type",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "nninterpolation",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dstmap1, dstmap2",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.convertMaps(",
    "local": ""
  },
  {
    "origin": "map1, map2, dstmap1type[, dstmap1[, dstmap2[, nninterpolation]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Converts image transformation maps from one representation to another.",
    "local": ""
  },
  {
    "origin": "The function converts a pair of maps for remap from one representation to another. The following options ( (map1.type(), map2.type()) \\(\\rightarrow\\) (dstmap1.type(), dstmap2.type()) ) are supported:",
    "local": ""
  },
  {
    "origin": "\\(\\texttt{(CV_32FC1, CV_32FC1)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\). This is the most frequently used conversion operation, in which the original floating-point maps (see remap ) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when nninterpolation=false ) contains indices in the interpolation tables.",
    "local": ""
  },
  {
    "origin": "\\(\\texttt{(CV_32FC2)} \\rightarrow \\texttt{(CV_16SC2, CV_16UC1)}\\). The same as above but the original maps are stored in one 2-channel matrix.",
    "local": ""
  },
  {
    "origin": "Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "map1",
    "local": ""
  },
  {
    "origin": "The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .",
    "local": ""
  },
  {
    "origin": "map2",
    "local": ""
  },
  {
    "origin": "The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix), respectively.",
    "local": ""
  },
  {
    "origin": "dstmap1",
    "local": ""
  },
  {
    "origin": "The first output map that has the type dstmap1type and the same size as src .",
    "local": ""
  },
  {
    "origin": "dstmap2",
    "local": ""
  },
  {
    "origin": "The second output map.",
    "local": ""
  },
  {
    "origin": "dstmap1type",
    "local": ""
  },
  {
    "origin": "Type of the first output map that should be CV_16SC2, CV_32FC1, or CV_32FC2 .",
    "local": ""
  },
  {
    "origin": "nninterpolation",
    "local": ""
  },
  {
    "origin": "Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getAffineTransform()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::getAffineTransform",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "[],",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "[]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.getAffineTransform(",
    "local": ""
  },
  {
    "origin": "src, dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates an affine transform from three pairs of the corresponding points.",
    "local": ""
  },
  {
    "origin": "The function calculates the \\(2 \\times 3\\) matrix of an affine transform so that:",
    "local": ""
  },
  {
    "origin": "\\[\\begin{bmatrix} x'_i \\\\ y'_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\]",
    "local": ""
  },
  {
    "origin": "where",
    "local": ""
  },
  {
    "origin": "\\[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2\\]",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Coordinates of triangle vertices in the source image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Coordinates of the corresponding triangle vertices in the destination image.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getAffineTransform()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::getAffineTransform",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.getAffineTransform(",
    "local": ""
  },
  {
    "origin": "src, dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getPerspectiveTransform()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "cv::getPerspectiveTransform",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "solveMethod",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.getPerspectiveTransform(",
    "local": ""
  },
  {
    "origin": "src, dst[, solveMethod]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates a perspective transform from four pairs of the corresponding points.",
    "local": ""
  },
  {
    "origin": "The function calculates the \\(3 \\times 3\\) matrix of a perspective transform so that:",
    "local": ""
  },
  {
    "origin": "\\[\\begin{bmatrix} t_i x'_i \\\\ t_i y'_i \\\\ t_i \\end{bmatrix} = \\texttt{map_matrix} \\cdot \\begin{bmatrix} x_i \\\\ y_i \\\\ 1 \\end{bmatrix}\\]",
    "local": ""
  },
  {
    "origin": "where",
    "local": ""
  },
  {
    "origin": "\\[dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\\]",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Coordinates of quadrangle vertices in the source image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Coordinates of the corresponding quadrangle vertices in the destination image.",
    "local": ""
  },
  {
    "origin": "solveMethod",
    "local": ""
  },
  {
    "origin": "method passed to",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getPerspectiveTransform()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "cv::getPerspectiveTransform",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "[],",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "[],",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "solveMethod",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.getPerspectiveTransform(",
    "local": ""
  },
  {
    "origin": "src, dst[, solveMethod]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRectSubPix()",
    "local": ""
  },
  {
    "origin": "void cv::getRectSubPix",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "patchSize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "patch",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "patchType",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "patch",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.getRectSubPix(",
    "local": ""
  },
  {
    "origin": "image, patchSize, center[, patch[, patchType]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Retrieves a pixel rectangle from an image with sub-pixel accuracy.",
    "local": ""
  },
  {
    "origin": "The function getRectSubPix extracts pixels from src:",
    "local": ""
  },
  {
    "origin": "\\[patch(x, y) = src(x + \\texttt{center.x} - ( \\texttt{dst.cols} -1)*0.5, y + \\texttt{center.y} - ( \\texttt{dst.rows} -1)*0.5)\\]",
    "local": ""
  },
  {
    "origin": "where the values of the pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multi-channel images is processed independently. Also the image should be a single channel or three channel image. While the center of the rectangle must be inside the image, parts of the rectangle may be outside.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "image",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "patchSize",
    "local": ""
  },
  {
    "origin": "Size of the extracted patch.",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": "Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image.",
    "local": ""
  },
  {
    "origin": "patch",
    "local": ""
  },
  {
    "origin": "Extracted patch that has the size patchSize and the same number of channels as src .",
    "local": ""
  },
  {
    "origin": "patchType",
    "local": ""
  },
  {
    "origin": "Depth of the extracted pixels. By default, they have the same depth as src .",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRotationMatrix2D()",
    "local": ""
  },
  {
    "origin": "cv::getRotationMatrix2D",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "angle",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "inline",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.getRotationMatrix2D(",
    "local": ""
  },
  {
    "origin": "center, angle, scale",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates an affine matrix of 2D rotation.",
    "local": ""
  },
  {
    "origin": "The function calculates the following matrix:",
    "local": ""
  },
  {
    "origin": "\\[\\begin{bmatrix} \\alpha &amp; \\beta &amp; (1- \\alpha ) \\cdot \\texttt{center.x} - \\beta \\cdot \\texttt{center.y} \\\\ - \\beta &amp; \\alpha &amp; \\beta \\cdot \\texttt{center.x} + (1- \\alpha ) \\cdot \\texttt{center.y} \\end{bmatrix}\\]",
    "local": ""
  },
  {
    "origin": "where",
    "local": ""
  },
  {
    "origin": "\\[\\begin{array}{l} \\alpha = \\texttt{scale} \\cdot \\cos \\texttt{angle} , \\\\ \\beta = \\texttt{scale} \\cdot \\sin \\texttt{angle} \\end{array}\\]",
    "local": ""
  },
  {
    "origin": "The transformation maps the rotation center to itself. If this is not the target, adjust the shift.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": "Center of the rotation in the source image.",
    "local": ""
  },
  {
    "origin": "angle",
    "local": ""
  },
  {
    "origin": "Rotation angle in degrees. Positive values mean counter-clockwise rotation (the coordinate origin is assumed to be the top-left corner).",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": "Isotropic scale factor.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRotationMatrix2D_()",
    "local": ""
  },
  {
    "origin": "cv::getRotationMatrix2D_",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "angle",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "scale",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "invertAffineTransform()",
    "local": ""
  },
  {
    "origin": "void cv::invertAffineTransform",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "iM",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "iM",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.invertAffineTransform(",
    "local": ""
  },
  {
    "origin": "M[, iM]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Inverts an affine transformation.",
    "local": ""
  },
  {
    "origin": "The function computes an inverse affine transformation represented by \\(2 \\times 3\\) matrix M:",
    "local": ""
  },
  {
    "origin": "\\[\\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1 \\\\ a_{21} &amp; a_{22} &amp; b_2 \\end{bmatrix}\\]",
    "local": ""
  },
  {
    "origin": "The result is also a \\(2 \\times 3\\) matrix of the same type as M.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "Original affine transformation.",
    "local": ""
  },
  {
    "origin": "iM",
    "local": ""
  },
  {
    "origin": "Output reverse affine transformation.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "linearPolar()",
    "local": ""
  },
  {
    "origin": "void cv::linearPolar",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "maxRadius",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.linearPolar(",
    "local": ""
  },
  {
    "origin": "src, center, maxRadius, flags[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Remaps an image to polar coordinates space.",
    "local": ""
  },
  {
    "origin": "This function produces same result as",
    "local": ""
  },
  {
    "origin": "(src, dst,",
    "local": ""
  },
  {
    "origin": ", center, maxRadius, flags)",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "logPolar()",
    "local": ""
  },
  {
    "origin": "void cv::logPolar",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.logPolar(",
    "local": ""
  },
  {
    "origin": "src, center, M, flags[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Remaps an image to semilog-polar coordinates space.",
    "local": ""
  },
  {
    "origin": "This function produces same result as",
    "local": ""
  },
  {
    "origin": "(src, dst,",
    "local": ""
  },
  {
    "origin": ", center, maxRadius, flags+WARP_POLAR_LOG);",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "remap()",
    "local": ""
  },
  {
    "origin": "void cv::remap",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "map1",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "map2",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.remap(",
    "local": ""
  },
  {
    "origin": "src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies a generic geometrical transformation to an image.",
    "local": ""
  },
  {
    "origin": "The function remap transforms the source image using the specified map:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\texttt{src} (map_x(x,y),map_y(x,y))\\]",
    "local": ""
  },
  {
    "origin": "where values of pixels with non-integer coordinates are computed using one of available interpolation methods. \\(map_x\\) and \\(map_y\\) can be encoded as separate floating-point maps in \\(map_1\\) and \\(map_2\\) respectively, or interleaved floating-point maps of \\((x,y)\\) in \\(map_1\\), or fixed-point maps created by using convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (2x) remapping operations. In the converted case, \\(map_1\\) contains pairs (cvFloor(x), cvFloor(y)) and \\(map_2\\) contains indices in a table of interpolation coefficients.",
    "local": ""
  },
  {
    "origin": "This function cannot operate in-place.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination image. It has the same size as map1 and the same type as src .",
    "local": ""
  },
  {
    "origin": "map1",
    "local": ""
  },
  {
    "origin": "The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point representation to fixed-point for speed.",
    "local": ""
  },
  {
    "origin": "map2",
    "local": ""
  },
  {
    "origin": "The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "Interpolation method (see",
    "local": ""
  },
  {
    "origin": "). The methods",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "are not supported by this function.",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "Pixel extrapolation method (see",
    "local": ""
  },
  {
    "origin": "). When borderMode=",
    "local": ""
  },
  {
    "origin": ", it means that the pixels in the destination image that corresponds to the \"outliers\" in the source image are not modified by the function.",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "Due to current implementation limitations the size of an input and output images should be less than 32767x32767.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "resize()",
    "local": ""
  },
  {
    "origin": "void cv::resize",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "fx",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "fy",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.resize(",
    "local": ""
  },
  {
    "origin": "src, dsize[, dst[, fx[, fy[, interpolation]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes an image.",
    "local": ""
  },
  {
    "origin": "The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ". If you want to resize src so that it fits the pre-created dst, you may call the function as follows:",
    "local": ""
  },
  {
    "origin": "If you want to decimate the image by factor of 2 in each direction, you can call the function this way:",
    "local": ""
  },
  {
    "origin": "To shrink an image, it will generally look best with",
    "local": ""
  },
  {
    "origin": "interpolation, whereas to enlarge an image, it will generally look best with c::INTER_CUBIC (slow) or",
    "local": ""
  },
  {
    "origin": "(faster but still looks OK).",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "output image; it has the size dsize (when it is non-zero) or the size computed from",
    "local": ""
  },
  {
    "origin": ", fx, and fy; the type of dst is the same as of src.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "output image size; if it equals zero, it is computed as:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\\]",
    "local": ""
  },
  {
    "origin": "Either dsize or both fx and fy must be non-zero.",
    "local": ""
  },
  {
    "origin": "fx",
    "local": ""
  },
  {
    "origin": "scale factor along the horizontal axis; when it equals 0, it is computed as",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{(double)dsize.width/src.cols}\\]",
    "local": ""
  },
  {
    "origin": "fy",
    "local": ""
  },
  {
    "origin": "scale factor along the vertical axis; when it equals 0, it is computed as",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{(double)dsize.height/src.rows}\\]",
    "local": ""
  },
  {
    "origin": "interpolation",
    "local": ""
  },
  {
    "origin": "interpolation method, see",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "warpAffine()",
    "local": ""
  },
  {
    "origin": "void cv::warpAffine",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.warpAffine(",
    "local": ""
  },
  {
    "origin": "src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies an affine transformation to an image.",
    "local": ""
  },
  {
    "origin": "The function warpAffine transforms the source image using the specified matrix:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\texttt{src} ( \\texttt{M} _{11} x + \\texttt{M} _{12} y + \\texttt{M} _{13}, \\texttt{M} _{21} x + \\texttt{M} _{22} y + \\texttt{M} _{23})\\]",
    "local": ""
  },
  {
    "origin": "when the flag",
    "local": ""
  },
  {
    "origin": "is set. Otherwise, the transformation is first inverted with",
    "local": ""
  },
  {
    "origin": "and then put in the formula above instead of M. The function cannot operate in-place.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "output image that has the size dsize and the same type as src .",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "\\(2\\times 3\\) transformation matrix.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "size of the output image.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "combination of interpolation methods (see",
    "local": ""
  },
  {
    "origin": ") and the optional flag",
    "local": ""
  },
  {
    "origin": "that means that M is the inverse transformation ( \\(\\texttt{dst}\\rightarrow\\texttt{src}\\) ).",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method (see",
    "local": ""
  },
  {
    "origin": "); when borderMode=",
    "local": ""
  },
  {
    "origin": ", it means that the pixels in the destination image corresponding to the \"outliers\" in the source image are not modified by the function.",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "warpPerspective()",
    "local": ""
  },
  {
    "origin": "void cv::warpPerspective",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.warpPerspective(",
    "local": ""
  },
  {
    "origin": "src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Applies a perspective transformation to an image.",
    "local": ""
  },
  {
    "origin": "The function warpPerspective transforms the source image using the specified matrix:",
    "local": ""
  },
  {
    "origin": "\\[\\texttt{dst} (x,y) = \\texttt{src} \\left ( \\frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} , \\frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \\right )\\]",
    "local": ""
  },
  {
    "origin": "when the flag",
    "local": ""
  },
  {
    "origin": "is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "output image that has the size dsize and the same type as src .",
    "local": ""
  },
  {
    "origin": "M",
    "local": ""
  },
  {
    "origin": "\\(3\\times 3\\) transformation matrix.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "size of the output image.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "combination of interpolation methods (",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": ") and the optional flag",
    "local": ""
  },
  {
    "origin": ", that sets M as the inverse transformation ( \\(\\texttt{dst}\\rightarrow\\texttt{src}\\) ).",
    "local": ""
  },
  {
    "origin": "borderMode",
    "local": ""
  },
  {
    "origin": "pixel extrapolation method (",
    "local": ""
  },
  {
    "origin": "or",
    "local": ""
  },
  {
    "origin": ").",
    "local": ""
  },
  {
    "origin": "borderValue",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ", and",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "warpPolar()",
    "local": ""
  },
  {
    "origin": "void cv::warpPolar",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "double",
    "local": ""
  },
  {
    "origin": "maxRadius",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.warpPolar(",
    "local": ""
  },
  {
    "origin": "src, dsize, center, maxRadius, flags[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Remaps an image to polar or semilog-polar coordinates space.",
    "local": ""
  },
  {
    "origin": "Polar remaps reference",
    "local": ""
  },
  {
    "origin": "Transform the source image using the following transformation:",
    "local": ""
  },
  {
    "origin": "\\[ dst(\\rho , \\phi ) = src(x,y) \\]",
    "local": ""
  },
  {
    "origin": "where",
    "local": ""
  },
  {
    "origin": "\\[ \\begin{array}{l} \\vec{I} = (x - center.x, \\;y - center.y) \\\\ \\phi = Kangle \\cdot \\texttt{angle} (\\vec{I}) \\\\ \\rho = \\left\\{\\begin{matrix} Klin \\cdot \\texttt{magnitude} (\\vec{I}) &amp; default \\\\ Klog \\cdot log_e(\\texttt{magnitude} (\\vec{I})) &amp; if \\; semilog \\\\ \\end{matrix}\\right. \\end{array} \\]",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": "\\[ \\begin{array}{l} Kangle = dsize.height / 2\\Pi \\\\ Klin = dsize.width / maxRadius \\\\ Klog = dsize.width / log_e(maxRadius) \\\\ \\end{array} \\]",
    "local": ""
  },
  {
    "origin": "Linear vs semilog mapping",
    "local": ""
  },
  {
    "origin": "Polar mapping can be linear or semi-log. Add one of",
    "local": ""
  },
  {
    "origin": "to",
    "local": ""
  },
  {
    "origin": "to specify the polar mapping mode.",
    "local": ""
  },
  {
    "origin": "Linear is the default mode.",
    "local": ""
  },
  {
    "origin": "The semilog mapping emulates the human \"foveal\" vision that permit very high acuity on the line of sight (central vision) in contrast to peripheral vision where acuity is minor.",
    "local": ""
  },
  {
    "origin": "Option on dsize:",
    "local": ""
  },
  {
    "origin": "if both values in",
    "local": ""
  },
  {
    "origin": "(default), the destination image will have (almost) same area of source bounding circle:",
    "local": ""
  },
  {
    "origin": "\\[\\begin{array}{l} dsize.area \\leftarrow (maxRadius^2 \\cdot \\Pi) \\\\ dsize.width = \\texttt{cvRound}(maxRadius) \\\\ dsize.height = \\texttt{cvRound}(maxRadius \\cdot \\Pi) \\\\ \\end{array}\\]",
    "local": ""
  },
  {
    "origin": "if only",
    "local": ""
  },
  {
    "origin": ", the destination image area will be proportional to the bounding circle area but scaled by",
    "local": ""
  },
  {
    "origin": ":",
    "local": ""
  },
  {
    "origin": "\\[\\begin{array}{l} dsize.height = \\texttt{cvRound}(dsize.width \\cdot \\Pi) \\\\ \\end{array} \\]",
    "local": ""
  },
  {
    "origin": "if both values in",
    "local": ""
  },
  {
    "origin": ", the destination image will have the given size therefore the area of the bounding circle will be scaled to",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Reverse mapping",
    "local": ""
  },
  {
    "origin": "You can get reverse mapping adding",
    "local": ""
  },
  {
    "origin": "to",
    "local": ""
  },
  {
    "origin": "In addiction, to calculate the original coordinate from a polar mapped coordinate \\((rho, phi)-&gt;(x, y)\\):",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "Source image.",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "Destination image. It will have same type as src.",
    "local": ""
  },
  {
    "origin": "dsize",
    "local": ""
  },
  {
    "origin": "The destination image size (see description for valid options).",
    "local": ""
  },
  {
    "origin": "center",
    "local": ""
  },
  {
    "origin": "The transformation center.",
    "local": ""
  },
  {
    "origin": "maxRadius",
    "local": ""
  },
  {
    "origin": "The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.",
    "local": ""
  },
  {
    "origin": "flags",
    "local": ""
  },
  {
    "origin": "A combination of interpolation methods,",
    "local": ""
  },
  {
    "origin": "+",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Add",
    "local": ""
  },
  {
    "origin": "to select linear polar mapping (default)",
    "local": ""
  },
  {
    "origin": "Add",
    "local": ""
  },
  {
    "origin": "to select semilog polar mapping",
    "local": ""
  },
  {
    "origin": "Add",
    "local": ""
  },
  {
    "origin": "for reverse mapping.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "The function can not operate in-place.",
    "local": ""
  },
  {
    "origin": "To calculate magnitude and angle in degrees",
    "local": ""
  },
  {
    "origin": "is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.",
    "local": ""
  },
  {
    "origin": "This function uses",
    "local": ""
  },
  {
    "origin": ". Due to current implementation limitations the size of an input and output images should be less than 32767x32767.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Examples:",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:40 for OpenCV by",
    "local": ""
  }
]