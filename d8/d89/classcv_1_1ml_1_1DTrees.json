[
  {
    "origin": "OpenCV: cv::ml::DTrees Class Reference",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Public Types",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions",
    "local": ""
  },
  {
    "origin": "List of all members",
    "local": ""
  },
  {
    "origin": "cv::ml::DTrees Class Reference",
    "local": ""
  },
  {
    "origin": "abstract",
    "local": ""
  },
  {
    "origin": "The class represents a single decision tree or a collection of decision trees.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Inheritance diagram for cv::ml::DTrees:",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "The class represents a decision tree node.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "class",
    "local": ""
  },
  {
    "origin": "The class represents split in a decision tree.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Types",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "=(1&lt;&lt;8),",
    "local": ""
  },
  {
    "origin": "=(2&lt;&lt;8),",
    "local": ""
  },
  {
    "origin": "=(3&lt;&lt;8)",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Public Types inherited from",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "Returns all the nodes.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "The array of a priori class probabilities, sorted by the class label value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt; int &gt; &amp;",
    "local": ""
  },
  {
    "origin": "Returns indices of root nodes.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "Returns all the splits.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt; int &gt; &amp;",
    "local": ""
  },
  {
    "origin": "Returns all the bitsets for categorical splits.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "The array of a priori class probabilities, sorted by the class label value.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;data, bool test,",
    "local": ""
  },
  {
    "origin": "resp) const",
    "local": ""
  },
  {
    "origin": "Computes error on the training or test dataset.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "() const",
    "local": ""
  },
  {
    "origin": "Returns true if the",
    "local": ""
  },
  {
    "origin": "is empty (e.g. in the very beginning or after unsuccessful read.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "Returns the number of variables in training samples.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "Returns true if the model is classifier.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "Returns true if the model is trained.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual float",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "samples,",
    "local": ""
  },
  {
    "origin": "results=",
    "local": ""
  },
  {
    "origin": "(), int flags=0) const =0",
    "local": ""
  },
  {
    "origin": "Predicts response(s) for the provided sample(s)",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;trainData, int flags=0)",
    "local": ""
  },
  {
    "origin": "Trains the statistical model.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "samples, int layout,",
    "local": ""
  },
  {
    "origin": "responses)",
    "local": ""
  },
  {
    "origin": "Trains the statistical model.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Clears the algorithm state.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "() const",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;fn)",
    "local": ""
  },
  {
    "origin": "Reads algorithm parameters from a file storage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename) const",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;fs) const",
    "local": ""
  },
  {
    "origin": "Stores algorithm parameters in a file storage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;fs, const",
    "local": ""
  },
  {
    "origin": "&amp;name=",
    "local": ""
  },
  {
    "origin": "()) const",
    "local": ""
  },
  {
    "origin": "simplified API for language bindings This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Creates the empty model.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filepath, const",
    "local": ""
  },
  {
    "origin": "&amp;nodeName=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads and creates a serialized",
    "local": ""
  },
  {
    "origin": "from a file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;data, int flags=0)",
    "local": ""
  },
  {
    "origin": "Create and train model with default parameters.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename, const",
    "local": ""
  },
  {
    "origin": "&amp;objname=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads algorithm from the file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;strModel, const",
    "local": ""
  },
  {
    "origin": "&amp;objname=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads algorithm from a String.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;fn)",
    "local": ""
  },
  {
    "origin": "Reads algorithm from the file node.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Additional Inherited Members",
    "local": ""
  },
  {
    "origin": "Protected Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;fs) const",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "The class represents a single decision tree or a collection of decision trees.",
    "local": ""
  },
  {
    "origin": "The current public interface of the class allows user to train only a single decision tree, however the class is capable of storing multiple decision trees and using them for prediction (by summing responses or using a voting schemes), and the derived from",
    "local": ""
  },
  {
    "origin": "classes (such as",
    "local": ""
  },
  {
    "origin": "and",
    "local": ""
  },
  {
    "origin": ") use this capability to implement decision tree ensembles.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "Member Enumeration Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "Flags",
    "local": ""
  },
  {
    "origin": "enum",
    "local": ""
  },
  {
    "origin": "Predict options",
    "local": ""
  },
  {
    "origin": "Enumerator",
    "local": ""
  },
  {
    "origin": "PREDICT_AUTO",
    "local": ""
  },
  {
    "origin": "PREDICT_SUM",
    "local": ""
  },
  {
    "origin": "PREDICT_MAX_VOTE",
    "local": ""
  },
  {
    "origin": "PREDICT_MASK",
    "local": ""
  },
  {
    "origin": "Member Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "create()",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::ml::DTrees::create",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml.DTrees_create(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Creates the empty model.",
    "local": ""
  },
  {
    "origin": "The static method creates empty decision tree with the specified parameters. It should be then trained using train method (see",
    "local": ""
  },
  {
    "origin": "). Alternatively, you can load the model from file using",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt;(filename).",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getCVFolds()",
    "local": ""
  },
  {
    "origin": "virtual int cv::ml::DTrees::getCVFolds",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getCVFolds(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "If CVFolds &gt; 1 then algorithms prunes the built decision tree using K-fold cross-validation procedure where K is equal to CVFolds. Default value is 10.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getMaxCategories()",
    "local": ""
  },
  {
    "origin": "virtual int cv::ml::DTrees::getMaxCategories",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getMaxCategories(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Cluster possible values of a categorical variable into K&lt;=maxCategories clusters to find a suboptimal split. If a discrete variable, on which the training procedure tries to make a split, takes more than maxCategories values, the precise best subset estimation may take a very long time because the algorithm is exponential. Instead, many decision trees engines (including our implementation) try to find sub-optimal split in this case by clustering all the samples into maxCategories clusters that is some categories are merged together. The clustering is applied only in n &gt; 2-class classification problems for categorical variables with N &gt; max_categories possible values. In case of regression and 2-class classification the optimal split can be found efficiently without employing clustering, thus the parameter is not used in these cases. Default value is 10.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getMaxDepth()",
    "local": ""
  },
  {
    "origin": "virtual int cv::ml::DTrees::getMaxDepth",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getMaxDepth(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "The maximum possible depth of the tree. That is the training algorithms attempts to split a node while its depth is less than maxDepth. The root node has zero depth. The actual depth may be smaller if the other termination criteria are met (see the outline of the training procedure",
    "local": ""
  },
  {
    "origin": "), and/or if the tree is pruned. Default value is INT_MAX.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getMinSampleCount()",
    "local": ""
  },
  {
    "origin": "virtual int cv::ml::DTrees::getMinSampleCount",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getMinSampleCount(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "If the number of samples in a node is less than this parameter then the node will not be split.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getNodes()",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;&amp; cv::ml::DTrees::getNodes",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Returns all the nodes.",
    "local": ""
  },
  {
    "origin": "all the node indices are indices in the returned vector",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getPriors()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "cv::ml::DTrees::getPriors",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getPriors(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "The array of a priori class probabilities, sorted by the class label value.",
    "local": ""
  },
  {
    "origin": "The parameter can be used to tune the decision tree preferences toward a certain class. For example, if you want to detect some rare anomaly occurrence, the training base will likely contain much more normal cases than anomalies, so a very good classification performance will be achieved just by considering every case as normal. To avoid this, the priors can be specified, where the anomaly probability is artificially increased (up to 0.5 or even greater), so the weight of the misclassified anomalies becomes much bigger, and the tree is adjusted properly.",
    "local": ""
  },
  {
    "origin": "You can also think about this parameter as weights of prediction categories which determine relative weights that you give to misclassification. That is, if the weight of the first category is 1 and the weight of the second category is 10, then each mistake in predicting the second category is equivalent to making 10 mistakes in predicting the first category. Default value is empty",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRegressionAccuracy()",
    "local": ""
  },
  {
    "origin": "virtual float cv::ml::DTrees::getRegressionAccuracy",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getRegressionAccuracy(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Termination criteria for regression trees. If all absolute differences between an estimated value in a node and values of train samples in this node are less than this parameter then the node will not be split further. Default value is 0.01f",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getRoots()",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt;int&gt;&amp; cv::ml::DTrees::getRoots",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Returns indices of root nodes.",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getSplits()",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt;&amp; cv::ml::DTrees::getSplits",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Returns all the splits.",
    "local": ""
  },
  {
    "origin": "all the split indices are indices in the returned vector",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getSubsets()",
    "local": ""
  },
  {
    "origin": "virtual const std::vector&lt;int&gt;&amp; cv::ml::DTrees::getSubsets",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Returns all the bitsets for categorical splits.",
    "local": ""
  },
  {
    "origin": "is an offset in the returned vector",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getTruncatePrunedTree()",
    "local": ""
  },
  {
    "origin": "virtual bool cv::ml::DTrees::getTruncatePrunedTree",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getTruncatePrunedTree(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "If true then pruned branches are physically removed from the tree. Otherwise they are retained and it is possible to get results from the original unpruned (or pruned less aggressively) tree. Default value is true.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getUse1SERule()",
    "local": ""
  },
  {
    "origin": "virtual bool cv::ml::DTrees::getUse1SERule",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getUse1SERule(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "If true then a pruning will be harsher. This will make a tree more compact and more resistant to the training data noise but a bit less accurate. Default value is true.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getUseSurrogates()",
    "local": ""
  },
  {
    "origin": "virtual bool cv::ml::DTrees::getUseSurrogates",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.getUseSurrogates(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "If true then surrogate splits will be built. These splits allow to work with missing data and compute variable importance correctly. Default value is false.",
    "local": ""
  },
  {
    "origin": "Note",
    "local": ""
  },
  {
    "origin": "currently it's not implemented.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "load()",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; cv::ml::DTrees::load",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "filepath",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "nodeName",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml.DTrees_load(",
    "local": ""
  },
  {
    "origin": "filepath[, nodeName]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Loads and creates a serialized",
    "local": ""
  },
  {
    "origin": "from a file.",
    "local": ""
  },
  {
    "origin": "Use DTree::save to serialize and store an DTree to disk. Load the DTree from this file again, by calling this function with the path to the file. Optionally specify the node for the file containing the classifier",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "filepath",
    "local": ""
  },
  {
    "origin": "path to serialized DTree",
    "local": ""
  },
  {
    "origin": "nodeName",
    "local": ""
  },
  {
    "origin": "name of node containing the classifier",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setCVFolds()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setCVFolds",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setCVFolds(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setMaxCategories()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setMaxCategories",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setMaxCategories(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setMaxDepth()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setMaxDepth",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setMaxDepth(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setMinSampleCount()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setMinSampleCount",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setMinSampleCount(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setPriors()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setPriors",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "&amp;",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setPriors(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "The array of a priori class probabilities, sorted by the class label value.",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setRegressionAccuracy()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setRegressionAccuracy",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "float",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setRegressionAccuracy(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setTruncatePrunedTree()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setTruncatePrunedTree",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setTruncatePrunedTree(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setUse1SERule()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setUse1SERule",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setUse1SERule(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setUseSurrogates()",
    "local": ""
  },
  {
    "origin": "virtual void cv::ml::DTrees::setUseSurrogates",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.ml_DTrees.setUseSurrogates(",
    "local": ""
  },
  {
    "origin": "val",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "See also",
    "local": ""
  },
  {
    "origin": "The documentation for this class was generated from the following file:",
    "local": ""
  },
  {
    "origin": "opencv2/",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:48 for OpenCV by",
    "local": ""
  }
]