[
  {
    "origin": "OpenCV: cv::AlignMTB Class Reference",
    "local": ""
  },
  {
    "origin": "OpenCV",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "List of all members",
    "local": ""
  },
  {
    "origin": "cv::AlignMTB Class Reference",
    "local": ""
  },
  {
    "origin": "abstract",
    "local": ""
  },
  {
    "origin": "»",
    "local": ""
  },
  {
    "origin": "This algorithm converts images to median threshold bitmaps (1 for pixels brighter than median luminance and 0 otherwise) and than aligns the resulting bitmaps using bit operations.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Inheritance diagram for cv::AlignMTB:",
    "local": ""
  },
  {
    "origin": "Public Member Functions",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img0,",
    "local": ""
  },
  {
    "origin": "img1)=0",
    "local": ""
  },
  {
    "origin": "Calculates shift between two images, i. e. how to shift the second image to correspond it with the first.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img,",
    "local": ""
  },
  {
    "origin": "tb,",
    "local": ""
  },
  {
    "origin": "Computes median threshold and exclude bitmaps of given image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "virtual int",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src, std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;dst,",
    "local": ""
  },
  {
    "origin": "times,",
    "local": ""
  },
  {
    "origin": "response)",
    "local": ""
  },
  {
    "origin": "Aligns images.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src, std::vector&lt;",
    "local": ""
  },
  {
    "origin": "Short version of process, that doesn't take extra arguments.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src,",
    "local": ""
  },
  {
    "origin": "dst, const",
    "local": ""
  },
  {
    "origin": "Helper function, that shift",
    "local": ""
  },
  {
    "origin": "filling new regions with zeros.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "()",
    "local": ""
  },
  {
    "origin": "Clears the algorithm state.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual bool",
    "local": ""
  },
  {
    "origin": "() const",
    "local": ""
  },
  {
    "origin": "Returns true if the",
    "local": ""
  },
  {
    "origin": "is empty (e.g. in the very beginning or after unsuccessful read.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "() const",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;fn)",
    "local": ""
  },
  {
    "origin": "Reads algorithm parameters from a file storage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename) const",
    "local": ""
  },
  {
    "origin": "virtual void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;fs) const",
    "local": ""
  },
  {
    "origin": "Stores algorithm parameters in a file storage.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;fs, const",
    "local": ""
  },
  {
    "origin": "&amp;name=",
    "local": ""
  },
  {
    "origin": "()) const",
    "local": ""
  },
  {
    "origin": "simplified API for language bindings This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Additional Inherited Members",
    "local": ""
  },
  {
    "origin": "Static Public Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;filename, const",
    "local": ""
  },
  {
    "origin": "&amp;objname=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads algorithm from the file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;strModel, const",
    "local": ""
  },
  {
    "origin": "&amp;objname=",
    "local": ""
  },
  {
    "origin": "())",
    "local": ""
  },
  {
    "origin": "Loads algorithm from a String.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "template&lt;typename _Tp &gt;",
    "local": ""
  },
  {
    "origin": "static",
    "local": ""
  },
  {
    "origin": "&lt; _Tp &gt;",
    "local": ""
  },
  {
    "origin": "(const",
    "local": ""
  },
  {
    "origin": "&amp;fn)",
    "local": ""
  },
  {
    "origin": "Reads algorithm from the file node.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Protected Member Functions inherited from",
    "local": ""
  },
  {
    "origin": "void",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "&amp;fs) const",
    "local": ""
  },
  {
    "origin": "Detailed Description",
    "local": ""
  },
  {
    "origin": "This algorithm converts images to median threshold bitmaps (1 for pixels brighter than median luminance and 0 otherwise) and than aligns the resulting bitmaps using bit operations.",
    "local": ""
  },
  {
    "origin": "It is invariant to exposure, so exposure values and camera response are not necessary.",
    "local": ""
  },
  {
    "origin": "In this implementation new image regions are filled with zeros.",
    "local": ""
  },
  {
    "origin": "For more information see",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "Member Function Documentation",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "calculateShift()",
    "local": ""
  },
  {
    "origin": "virtual",
    "local": ""
  },
  {
    "origin": "cv::AlignMTB::calculateShift",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img0",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "img1",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.calculateShift(",
    "local": ""
  },
  {
    "origin": "img0, img1",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Calculates shift between two images, i. e. how to shift the second image to correspond it with the first.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "img0",
    "local": ""
  },
  {
    "origin": "first image",
    "local": ""
  },
  {
    "origin": "img1",
    "local": ""
  },
  {
    "origin": "second image",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "computeBitmaps()",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::computeBitmaps",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "tb",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "eb",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "tb, eb",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.computeBitmaps(",
    "local": ""
  },
  {
    "origin": "img[, tb[, eb]]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Computes median threshold and exclude bitmaps of given image.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "img",
    "local": ""
  },
  {
    "origin": "input image",
    "local": ""
  },
  {
    "origin": "tb",
    "local": ""
  },
  {
    "origin": "median threshold bitmap",
    "local": ""
  },
  {
    "origin": "eb",
    "local": ""
  },
  {
    "origin": "exclude bitmap",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getCut()",
    "local": ""
  },
  {
    "origin": "virtual bool cv::AlignMTB::getCut",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.getCut(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getExcludeRange()",
    "local": ""
  },
  {
    "origin": "virtual int cv::AlignMTB::getExcludeRange",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.getExcludeRange(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "getMaxBits()",
    "local": ""
  },
  {
    "origin": "virtual int cv::AlignMTB::getMaxBits",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "retval",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.getMaxBits(",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "process()",
    "local": ""
  },
  {
    "origin": "[1/2]",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::process",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "times",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "response",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.process(",
    "local": ""
  },
  {
    "origin": "src, dst, times, response",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.process(",
    "local": ""
  },
  {
    "origin": "src, dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Aligns images.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "vector of input images",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "vector of aligned images",
    "local": ""
  },
  {
    "origin": "times",
    "local": ""
  },
  {
    "origin": "vector of exposure time values for each image",
    "local": ""
  },
  {
    "origin": "response",
    "local": ""
  },
  {
    "origin": "256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images.",
    "local": ""
  },
  {
    "origin": "Implements",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "process()",
    "local": ""
  },
  {
    "origin": "[2/2]",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::process",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "std::vector&lt;",
    "local": ""
  },
  {
    "origin": "&gt; &amp;",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.process(",
    "local": ""
  },
  {
    "origin": "src, dst, times, response",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.process(",
    "local": ""
  },
  {
    "origin": "src, dst",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Short version of process, that doesn't take extra arguments.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "vector of input images",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "vector of aligned images",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setCut()",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::setCut",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "bool",
    "local": ""
  },
  {
    "origin": "value",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.setCut(",
    "local": ""
  },
  {
    "origin": "value",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setExcludeRange()",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::setExcludeRange",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "exclude_range",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.setExcludeRange(",
    "local": ""
  },
  {
    "origin": "exclude_range",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "setMaxBits()",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::setMaxBits",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "int",
    "local": ""
  },
  {
    "origin": "max_bits",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "None",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.setMaxBits(",
    "local": ""
  },
  {
    "origin": "max_bits",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "◆",
    "local": ""
  },
  {
    "origin": "shiftMat()",
    "local": ""
  },
  {
    "origin": "virtual void cv::AlignMTB::shiftMat",
    "local": ""
  },
  {
    "origin": "(",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": ",",
    "local": ""
  },
  {
    "origin": "const",
    "local": ""
  },
  {
    "origin": "shift",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "pure virtual",
    "local": ""
  },
  {
    "origin": "Python:",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "=",
    "local": ""
  },
  {
    "origin": "cv.AlignMTB.shiftMat(",
    "local": ""
  },
  {
    "origin": "src, shift[, dst]",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Helper function, that shift",
    "local": ""
  },
  {
    "origin": "filling new regions with zeros.",
    "local": ""
  },
  {
    "origin": "Parameters",
    "local": ""
  },
  {
    "origin": "src",
    "local": ""
  },
  {
    "origin": "input image",
    "local": ""
  },
  {
    "origin": "dst",
    "local": ""
  },
  {
    "origin": "result image",
    "local": ""
  },
  {
    "origin": "shift",
    "local": ""
  },
  {
    "origin": "shift value",
    "local": ""
  },
  {
    "origin": "The documentation for this class was generated from the following file:",
    "local": ""
  },
  {
    "origin": "opencv2/",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:42 for OpenCV by",
    "local": ""
  }
]