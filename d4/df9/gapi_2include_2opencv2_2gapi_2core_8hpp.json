[
  {
    "origin": "OpenCV: opencv2/gapi/core.hpp File Reference",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "Typedefs",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "core.hpp File Reference",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "\"black box\" representation of the file storage associated with a file on disk.",
    "local": ""
  },
  {
    "origin": "Typedefs",
    "local": ""
  },
  {
    "origin": "= std::tuple&lt; GMat, GMat &gt;",
    "local": ""
  },
  {
    "origin": "= std::tuple&lt; GMat, GMat, GMat &gt;",
    "local": ""
  },
  {
    "origin": "= std::tuple&lt; GMat, GMat, GMat, GMat &gt;",
    "local": ""
  },
  {
    "origin": "= std::tuple&lt; GMat, GScalar &gt;",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element absolute difference between two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;c)",
    "local": ""
  },
  {
    "origin": "Calculates absolute value of matrix elements.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element sum of two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;c, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element sum of matrix and given scalar.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GScalar &amp;c, const GMat &amp;src1, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, double alpha, const GMat &amp;src2, double beta, double gamma, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the weighted sum of two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "computes bitwise conjunction of the two matrixes (src1 &amp; src2) Calculates the per-element bit-wise logical conjunction of two matrices of the same size.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Inverts every bit of an array.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "computes bitwise disjunction of the two matrixes (src1 | src2) Calculates the per-element bit-wise logical disjunction of two matrices of the same size.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "computes bitwise logical \"exclusive or\" of the two matrixes (src1 ^ src2) Calculates the per-element bit-wise logical \"exclusive or\" of two matrices of the same size.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;x, const GMat &amp;y, bool angleInDegrees=false)",
    "local": ""
  },
  {
    "origin": "Calculates the magnitude and angle of 2D vectors.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Performs the per-element comparison of two matrices checking if elements from first matrix are equal to elements in second.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Performs the per-element comparison of two matrices checking if elements from first matrix are greater or equal compare to elements in second.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Performs the per-element comparison of two matrices checking if elements from first matrix are greater compare to elements in second.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Performs the per-element comparison of two matrices checking if elements from first matrix are less or equal compare to elements in second.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Performs the per-element comparison of two matrices checking if elements from first matrix are less than elements in second.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Performs the per-element comparison of two matrices checking if elements from first matrix are not equal to elements in second.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GScalar &amp;src2)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Applies horizontal concatenation to given matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt; GMat &gt; &amp;v)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Applies vertical concatenation to given matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const std::vector&lt; GMat &gt; &amp;v)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, int rdepth, double alpha=1, double beta=0)",
    "local": ""
  },
  {
    "origin": "Converts a matrix to another data depth with optional scaling.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Counts non-zero array elements.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const Rect &amp;rect)",
    "local": ""
  },
  {
    "origin": "Crops a 2D matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, double scale, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Performs per-element division of two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;divisor, double scale, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Divides matrix by scalar.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GScalar &amp;divident, const GMat &amp;src, double scale, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Divides scalar by matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, int flipCode)",
    "local": ""
  },
  {
    "origin": "Flips a 2D matrix around vertical, horizontal, or both axes.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(GAdd,&lt; GMat(GMat, GMat, int)&gt;, &quot;org.opencv.core.math.add&quot;)",
    "local": ""
  },
  {
    "origin": "(GAddC,&lt; GMat(GMat, GScalar, int)&gt;, &quot;org.opencv.core.math.addC&quot;)",
    "local": ""
  },
  {
    "origin": "(GSub,&lt; GMat(GMat, GMat, int)&gt;, &quot;org.opencv.core.math.sub&quot;)",
    "local": ""
  },
  {
    "origin": "(GSubC,&lt; GMat(GMat, GScalar, int)&gt;, &quot;org.opencv.core.math.subC&quot;)",
    "local": ""
  },
  {
    "origin": "(GSubRC,&lt; GMat(GScalar, GMat, int)&gt;, &quot;org.opencv.core.math.subRC&quot;)",
    "local": ""
  },
  {
    "origin": "(GMul,&lt; GMat(GMat, GMat, double, int)&gt;, &quot;org.opencv.core.math.mul&quot;)",
    "local": ""
  },
  {
    "origin": "(GMulCOld,&lt; GMat(GMat, double, int)&gt;, &quot;org.opencv.core.math.mulCOld&quot;)",
    "local": ""
  },
  {
    "origin": "(GMulC,&lt; GMat(GMat, GScalar, int)&gt;, &quot;org.opencv.core.math.mulC&quot;)",
    "local": ""
  },
  {
    "origin": "(GMulS,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.math.muls&quot;)",
    "local": ""
  },
  {
    "origin": "(GDiv,&lt; GMat(GMat, GMat, double, int)&gt;, &quot;org.opencv.core.math.div&quot;)",
    "local": ""
  },
  {
    "origin": "(GDivC,&lt; GMat(GMat, GScalar, double, int)&gt;, &quot;org.opencv.core.math.divC&quot;)",
    "local": ""
  },
  {
    "origin": "(GDivRC,&lt; GMat(GScalar, GMat, double, int)&gt;, &quot;org.opencv.core.math.divRC&quot;)",
    "local": ""
  },
  {
    "origin": "(GMean,&lt; GScalar(GMat)&gt;, &quot;org.opencv.core.math.mean&quot;)",
    "local": ""
  },
  {
    "origin": "(GPhase,&lt; GMat(GMat, GMat, bool)&gt;, &quot;org.opencv.core.math.phase&quot;)",
    "local": ""
  },
  {
    "origin": "(GMask,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.mask&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpGT,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpGT&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpGE,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpGE&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpLE,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpLE&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpLT,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpLT&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpEQ,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpEQ&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpNE,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpNE&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpGTScalar,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpGTScalar&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpGEScalar,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpGEScalar&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpLEScalar,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpLEScalar&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpLTScalar,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpLTScalar&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpEQScalar,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpEQScalar&quot;)",
    "local": ""
  },
  {
    "origin": "(GCmpNEScalar,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.compare.cmpNEScalar&quot;)",
    "local": ""
  },
  {
    "origin": "(GAnd,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.bitwise_and&quot;)",
    "local": ""
  },
  {
    "origin": "(GAndS,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.bitwise_andS&quot;)",
    "local": ""
  },
  {
    "origin": "(GOr,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.bitwise_or&quot;)",
    "local": ""
  },
  {
    "origin": "(GOrS,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.bitwise_orS&quot;)",
    "local": ""
  },
  {
    "origin": "(GXor,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.bitwise_xor&quot;)",
    "local": ""
  },
  {
    "origin": "(GXorS,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.pixelwise.bitwise_xorS&quot;)",
    "local": ""
  },
  {
    "origin": "(GNot,&lt; GMat(GMat)&gt;, &quot;org.opencv.core.pixelwise.bitwise_not&quot;)",
    "local": ""
  },
  {
    "origin": "(GSelect,&lt; GMat(GMat, GMat, GMat)&gt;, &quot;org.opencv.core.pixelwise.select&quot;)",
    "local": ""
  },
  {
    "origin": "(GMin,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.matrixop.min&quot;)",
    "local": ""
  },
  {
    "origin": "(GMax,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.matrixop.max&quot;)",
    "local": ""
  },
  {
    "origin": "(GAbsDiff,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.core.matrixop.absdiff&quot;)",
    "local": ""
  },
  {
    "origin": "(GAbsDiffC,&lt; GMat(GMat, GScalar)&gt;, &quot;org.opencv.core.matrixop.absdiffC&quot;)",
    "local": ""
  },
  {
    "origin": "(GSum,&lt; GScalar(GMat)&gt;, &quot;org.opencv.core.matrixop.sum&quot;)",
    "local": ""
  },
  {
    "origin": "(GCountNonZero,&lt; GOpaque&lt; int &gt;(GMat)&gt;, &quot;org.opencv.core.matrixop.countNonZero&quot;)",
    "local": ""
  },
  {
    "origin": "(GAddW,&lt; GMat(GMat, double, GMat, double, double, int)&gt;, &quot;org.opencv.core.matrixop.addweighted&quot;)",
    "local": ""
  },
  {
    "origin": "(GNormL1,&lt; GScalar(GMat)&gt;, &quot;org.opencv.core.matrixop.norml1&quot;)",
    "local": ""
  },
  {
    "origin": "(GNormL2,&lt; GScalar(GMat)&gt;, &quot;org.opencv.core.matrixop.norml2&quot;)",
    "local": ""
  },
  {
    "origin": "(GNormInf,&lt; GScalar(GMat)&gt;, &quot;org.opencv.core.matrixop.norminf&quot;)",
    "local": ""
  },
  {
    "origin": "(GThreshold,&lt; GMat(GMat, GScalar, GScalar, int)&gt;, &quot;org.opencv.core.matrixop.threshold&quot;)",
    "local": ""
  },
  {
    "origin": "(GInRange,&lt; GMat(GMat, GScalar, GScalar)&gt;, &quot;org.opencv.core.matrixop.inrange&quot;)",
    "local": ""
  },
  {
    "origin": "(GResize,&lt; GMat(GMat, Size, double, double, int)&gt;, &quot;org.opencv.core.transform.resize&quot;)",
    "local": ""
  },
  {
    "origin": "(GResizeP,&lt; GMatP(GMatP, Size, int)&gt;, &quot;org.opencv.core.transform.resizeP&quot;)",
    "local": ""
  },
  {
    "origin": "(GMerge3,&lt; GMat(GMat, GMat, GMat)&gt;, &quot;org.opencv.core.transform.merge3&quot;)",
    "local": ""
  },
  {
    "origin": "(GMerge4,&lt; GMat(GMat, GMat, GMat, GMat)&gt;, &quot;org.opencv.core.transform.merge4&quot;)",
    "local": ""
  },
  {
    "origin": "(GRemap,&lt; GMat(GMat, Mat, Mat, int, int, Scalar)&gt;, &quot;org.opencv.core.transform.remap&quot;)",
    "local": ""
  },
  {
    "origin": "(GFlip,&lt; GMat(GMat, int)&gt;, &quot;org.opencv.core.transform.flip&quot;)",
    "local": ""
  },
  {
    "origin": "(GCrop,&lt; GMat(GMat, Rect)&gt;, &quot;org.opencv.core.transform.crop&quot;)",
    "local": ""
  },
  {
    "origin": "(GConcatHor,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.imgproc.transform.concatHor&quot;)",
    "local": ""
  },
  {
    "origin": "(GConcatVert,&lt; GMat(GMat, GMat)&gt;, &quot;org.opencv.imgproc.transform.concatVert&quot;)",
    "local": ""
  },
  {
    "origin": "(GLUT,&lt; GMat(GMat, Mat)&gt;, &quot;org.opencv.core.transform.LUT&quot;)",
    "local": ""
  },
  {
    "origin": "(GConvertTo,&lt; GMat(GMat, int, double, double)&gt;, &quot;org.opencv.core.transform.convertTo&quot;)",
    "local": ""
  },
  {
    "origin": "(GSqrt,&lt; GMat(GMat)&gt;, &quot;org.opencv.core.math.sqrt&quot;)",
    "local": ""
  },
  {
    "origin": "(GNormalize,&lt; GMat(GMat, double, double, int, int)&gt;, &quot;org.opencv.core.normalize&quot;)",
    "local": ""
  },
  {
    "origin": "(GWarpPerspective,&lt; GMat(GMat, const Mat &amp;, Size, int, int, const",
    "local": ""
  },
  {
    "origin": "&amp;)&gt;, &quot;org.opencv.core.warpPerspective&quot;)",
    "local": ""
  },
  {
    "origin": "(GWarpAffine,&lt; GMat(GMat, const Mat &amp;, Size, int, int, const",
    "local": ""
  },
  {
    "origin": "&amp;)&gt;, &quot;org.opencv.core.warpAffine&quot;)",
    "local": ""
  },
  {
    "origin": "(GKMeansND,&lt; std::tuple&lt; GOpaque&lt; double &gt;, GMat, GMat &gt;(GMat, int, GMat, TermCriteria, int, KmeansFlags)&gt;, &quot;org.opencv.core.kmeansND&quot;)",
    "local": ""
  },
  {
    "origin": "(GKMeansNDNoInit,&lt; std::tuple&lt; GOpaque&lt; double &gt;, GMat, GMat &gt;(GMat, int, TermCriteria, int, KmeansFlags)&gt;, &quot;org.opencv.core.kmeansNDNoInit&quot;)",
    "local": ""
  },
  {
    "origin": "(GKMeans2D,&lt; std::tuple&lt; GOpaque&lt; double &gt;, GArray&lt; int &gt;, GArray&lt; Point2f &gt;&gt;(GArray&lt; Point2f &gt;, int, GArray&lt; int &gt;, TermCriteria, int, KmeansFlags)&gt;, &quot;org.opencv.core.kmeans2D&quot;)",
    "local": ""
  },
  {
    "origin": "(GKMeans3D,&lt; std::tuple&lt; GOpaque&lt; double &gt;, GArray&lt; int &gt;, GArray&lt; Point3f &gt;&gt;(GArray&lt; Point3f &gt;, int, GArray&lt; int &gt;, TermCriteria, int, KmeansFlags)&gt;, &quot;org.opencv.core.kmeans3D&quot;)",
    "local": ""
  },
  {
    "origin": "(GSize,&lt; GOpaque&lt; Size &gt;(GMat)&gt;, &quot;org.opencv.streaming.size&quot;)",
    "local": ""
  },
  {
    "origin": "(GSizeR,&lt; GOpaque&lt; Size &gt;(GOpaque&lt; Rect &gt;)&gt;, &quot;org.opencv.streaming.sizeR&quot;)",
    "local": ""
  },
  {
    "origin": "(GSizeMF,&lt; GOpaque&lt; Size &gt;(GFrame)&gt;, &quot;org.opencv.streaming.sizeMF&quot;)",
    "local": ""
  },
  {
    "origin": "(GPolarToCart,&lt; GMat2(GMat, GMat, bool)&gt;, &quot;org.opencv.core.math.polarToCart&quot;)",
    "local": ""
  },
  {
    "origin": "(GCartToPolar,&lt; GMat2(GMat, GMat, bool)&gt;, &quot;org.opencv.core.math.cartToPolar&quot;)",
    "local": ""
  },
  {
    "origin": "(GIntegral,&lt; GMat2(GMat, int, int)&gt;, &quot;org.opencv.core.matrixop.integral&quot;)",
    "local": ""
  },
  {
    "origin": "(GThresholdOT,&lt; GMatScalar(GMat, GScalar, int)&gt;, &quot;org.opencv.core.matrixop.thresholdOT&quot;)",
    "local": ""
  },
  {
    "origin": "(GSplit3,&lt; GMat3(GMat)&gt;, &quot;org.opencv.core.transform.split3&quot;)",
    "local": ""
  },
  {
    "origin": "(GSplit4,&lt; GMat4(GMat)&gt;,&quot;org.opencv.core.transform.split4&quot;)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;threshLow, const GScalar &amp;threshUp)",
    "local": ""
  },
  {
    "origin": "Applies a range-level threshold to each matrix element.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, int sdepth=-1, int sqdepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the integral of an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;data, const int K, const GMat &amp;bestLabels, const TermCriteria &amp;criteria, const int attempts, const KmeansFlags flags)",
    "local": ""
  },
  {
    "origin": "Finds centers of clusters and groups input samples around the clusters.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;data, const int K, const TermCriteria &amp;criteria, const int attempts, const KmeansFlags flags)",
    "local": ""
  },
  {
    "origin": "std::tuple&lt; GOpaque&lt; double &gt;, GArray&lt; int &gt;, GArray&lt; Point2f &gt; &gt;&#160;",
    "local": ""
  },
  {
    "origin": "(const GArray&lt; Point2f &gt; &amp;data, const int K, const GArray&lt; int &gt; &amp;bestLabels, const TermCriteria &amp;criteria, const int attempts, const KmeansFlags flags)",
    "local": ""
  },
  {
    "origin": "std::tuple&lt; GOpaque&lt; double &gt;, GArray&lt; int &gt;, GArray&lt; Point3f &gt; &gt;&#160;",
    "local": ""
  },
  {
    "origin": "(const GArray&lt; Point3f &gt; &amp;data, const int K, const GArray&lt; int &gt; &amp;bestLabels, const TermCriteria &amp;criteria, const int attempts, const KmeansFlags flags)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const Mat &amp;lut)",
    "local": ""
  },
  {
    "origin": "Performs a look-up table transform of a matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GMat &amp;mask)",
    "local": ""
  },
  {
    "origin": "Applies a mask to a matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Calculates per-element maximum of two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Calculates an average (mean) of matrix elements.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, const GMat &amp;src3)",
    "local": ""
  },
  {
    "origin": "Creates one 3-channel matrix out of 3 single-channel ones.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, const GMat &amp;src3, const GMat &amp;src4)",
    "local": ""
  },
  {
    "origin": "Creates one 4-channel matrix out of 4 single-channel ones.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2)",
    "local": ""
  },
  {
    "origin": "Calculates per-element minimum of two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, double scale=1.0, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element scaled product of two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, double multiplier, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Multiplies matrix by scalar.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;multiplier, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "(const GScalar &amp;multiplier, const GMat &amp;src, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, double alpha, double beta, int norm_type, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Normalizes the norm or value range of an array.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Calculates the absolute infinite norm of a matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Calculates the absolute",
    "local": ""
  },
  {
    "origin": "norm of a matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Calculates the absolute",
    "local": ""
  },
  {
    "origin": "norm of a matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;x, const GMat &amp;y, bool angleInDegrees=false)",
    "local": ""
  },
  {
    "origin": "Calculates the rotation angle of 2D vectors.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;magnitude, const GMat &amp;angle, bool angleInDegrees=false)",
    "local": ""
  },
  {
    "origin": "Calculates x and y coordinates of 2D vectors from their magnitude and angle.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const Mat &amp;map1, const Mat &amp;map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar &amp;borderValue=Scalar())",
    "local": ""
  },
  {
    "origin": "Applies a generic geometrical transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const Size &amp;dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR)",
    "local": ""
  },
  {
    "origin": "Resizes an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMatP &amp;src, const Size &amp;dsize, int interpolation=",
    "local": ""
  },
  {
    "origin": ")",
    "local": ""
  },
  {
    "origin": "Resizes a planar image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, const GMat &amp;mask)",
    "local": ""
  },
  {
    "origin": "Select values from either first or second of input matrices by given mask. The function set to the output matrix either the value from the first input matrix if corresponding value of mask matrix is 255, or value from the second input matrix (if value of mask matrix set to 0).",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Gets dimensions from",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GOpaque&lt; Rect &gt; &amp;r)",
    "local": ""
  },
  {
    "origin": "(const GFrame &amp;src)",
    "local": ""
  },
  {
    "origin": "Gets dimensions from",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Divides a 3-channel matrix into 3 single-channel matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Divides a 4-channel matrix into 4 single-channel matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Calculates a square root of array elements.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src1, const GMat &amp;src2, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element difference between two matrices.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;c, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element difference between matrix and given scalar.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GScalar &amp;c, const GMat &amp;src, int ddepth=-1)",
    "local": ""
  },
  {
    "origin": "Calculates the per-element difference between given scalar and the matrix.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src)",
    "local": ""
  },
  {
    "origin": "Calculates sum of all matrix elements.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;thresh, const GScalar &amp;maxval, int type)",
    "local": ""
  },
  {
    "origin": "Applies a fixed-level threshold to each matrix element.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const GScalar &amp;maxval, int type)",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const Mat &amp;M, const Size &amp;dsize, int flags=",
    "local": ""
  },
  {
    "origin": ", int borderMode=",
    "local": ""
  },
  {
    "origin": ", const Scalar &amp;borderValue=Scalar())",
    "local": ""
  },
  {
    "origin": "Applies an affine transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const GMat &amp;src, const Mat &amp;M, const Size &amp;dsize, int flags=",
    "local": ""
  },
  {
    "origin": ", int borderMode=",
    "local": ""
  },
  {
    "origin": ", const Scalar &amp;borderValue=Scalar())",
    "local": ""
  },
  {
    "origin": "Applies a perspective transformation to an image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:33 for OpenCV by &#160;",
    "local": ""
  }
]