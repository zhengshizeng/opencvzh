[
  {
    "origin": "OpenCV: opencv2/video/tracking.hpp File Reference",
    "local": ""
  },
  {
    "origin": "Open Source Computer Vision",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "tracking.hpp File Reference",
    "local": ""
  },
  {
    "origin": "Classes",
    "local": ""
  },
  {
    "origin": "DIS optical flow algorithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Class computing a dense optical flow using the Gunnar Farneback's algorithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Kalman filter class.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Base interface for sparse optical flow algorithms.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Class used for calculating a sparse optical flow.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Base abstract class for the long-term tracker.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "the GOTURN (Generic Object Tracking Using Regression Networks) tracker",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "The MIL algorithm trains a classifier in an online manner to separate the object from the background.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Variational optical flow refinement.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Namespaces",
    "local": ""
  },
  {
    "origin": "\"black box\" representation of the file storage associated with a file on disk.",
    "local": ""
  },
  {
    "origin": "Enumerations",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "{",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "&#160;&#160;",
    "local": ""
  },
  {
    "origin": "}",
    "local": ""
  },
  {
    "origin": "Functions",
    "local": ""
  },
  {
    "origin": "(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives=true, int pyrBorder=BORDER_REFLECT_101, int derivBorder=BORDER_CONSTANT, bool tryReuseInputImage=true)",
    "local": ""
  },
  {
    "origin": "Constructs the image pyramid which can be passed to calcOpticalFlowPyrLK.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)",
    "local": ""
  },
  {
    "origin": "Computes a dense optical flow using the Gunnar Farneback's algorithm.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize=Size(21, 21), int maxLevel=3, TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), int flags=0, double minEigThreshold=1e-4)",
    "local": ""
  },
  {
    "origin": "Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray probImage, Rect &amp;window, TermCriteria criteria)",
    "local": ""
  },
  {
    "origin": "Finds an object center, size, and orientation.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray templateImage, InputArray inputImage, InputArray inputMask=noArray())",
    "local": ""
  },
  {
    "origin": "Computes the Enhanced Correlation Coefficient value between two images",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray src, InputArray dst, bool fullAffine)",
    "local": ""
  },
  {
    "origin": "Computes an optimal affine transformation between two 2D point sets.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria, InputArray inputMask, int gaussFiltSize)",
    "local": ""
  },
  {
    "origin": "Finds the geometric transform (warp) between two images in terms of the ECC criterion",
    "local": ""
  },
  {
    "origin": ".",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType=MOTION_AFFINE, TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), InputArray inputMask=noArray())",
    "local": ""
  },
  {
    "origin": "(InputArray probImage, Rect &amp;window, TermCriteria criteria)",
    "local": ""
  },
  {
    "origin": "Finds an object on a back projection image.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const String &amp;path)",
    "local": ""
  },
  {
    "origin": "Read a .flo file.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "(const String &amp;path, InputArray flow)",
    "local": ""
  },
  {
    "origin": "Write a .flo to disk.",
    "local": ""
  },
  {
    "origin": "More...",
    "local": ""
  },
  {
    "origin": "Generated on Fri Apr 2 2021 11:36:33 for OpenCV by &#160;",
    "local": ""
  }
]